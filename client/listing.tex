\documentclass[listing]{espd}
\usepackage[russian]{babel}

\bibliographystyle{gost2008}

\managerrank{Научный руководитель,\\доцент департамента\\программной инженерии\\факультета компьютерных наук,\\канд. техн. наук}
\manager{С.Л. Макаров}

\authorrank{студент группы БПИ183}
\author{М.И. Сердюков}

\title{Мессенджер с поиском по Bluetooth\\(клиентская часть)}
\code{04.03}

\city{Москва}
\year{2021}

\begin{document}

\annotation

Текст программы -- это документ, содержащий исходный код программы. Каждому файлу соответствует его подраздел. Ввиду того, что в исходном коде встречаются символы Unicode, данные символы в приведенном ниже коде заменены на обозначения через обратную косую черту. В данном документе содержатся следующие разделы: <<Исходный код редактора>>, <<Исходный код просмотрщика>>, <<Исходный код тестов>>, <<Исходный код бенчмарков>>.

В разделе <<Исходный код модуля app>> приведен код классов, отвечающий за логику приложения и ее интерфейс.

В разделе <<Исходный код ресурсов для app>> приведен код xml ресурсов, отвечающих за UI приложения.

В разделе <<Исходный код тестов для app>> приведен код тестов.

В разделе <<Исходный код модуля api>> приведен код для обращения к api сервера.

В разделе <<Исходный код модуля develop>> приведен код классов, для инфраструктуры разработки.

Настоящий Текст программы удовлетворяет требованиям ГОСТ 19.401-78~\cite{espd401}.

\tableofcontents
\section{Исходный код модуля app}

\subsection{MainApplication.kt}
\begin{verbatim}
package com.closecom.app
import android.app.Application
import com.closecom.app.di.AppSdk
import com.closecom.develop.di.DevSdk
class MainApplication : Application() {
    override fun onCreate() {
        super.onCreate()
        DevSdk.init(applicationContext)
        AppSdk.init(applicationContext, DevSdk.devComponent)
    }
}
\end{verbatim}

\subsection{MainActivity.kt}
\begin{verbatim}
package com.closecom.app.ui
import android.os.Bundle
import android.view.Gravity
import android.view.WindowManager
import androidx.appcompat.app.ActionBarDrawerToggle
import androidx.appcompat.app.AppCompatActivity
import androidx.core.content.ContextCompat
import androidx.drawerlayout.widget.DrawerLayout
import androidx.fragment.app.Fragment
import com.arellomobile.mvp.presenter.InjectPresenter
import com.closecom.R
import com.closecom.app.di.AppSdk
import com.closecom.app.domain.model.ScreenType
import com.closecom.app.domain.repo.mappers.ScreenMapper
import com.closecom.app.ui.navigation.NavigationPresenter
import com.closecom.app.ui.navigation.NavigationView
import javax.inject.Inject
import kotlinx.android.synthetic.main.activity_main.*
private const val PERMISSION_REQUEST = 0
class MainActivity : AppCompatActivity(), NavigationView {
    @Inject
    @InjectPresenter
    lateinit var presenter: NavigationPresenter
    @Inject
    lateinit var screenMapper: ScreenMapper
    private lateinit var toggle: ActionBarDrawerToggle
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        AppSdk.appComponent.inject(this)
        setContentView(R.layout.activity_main)
        setSupportActionBar(top_toolbar)
        overrideStatusBarColor()
        toggle = ActionBarDrawerToggle(
            this,
            drawer_layout,
            top_toolbar,
            R.string.drawer_layout_open,
            R.string.drawer_layout_close
        )
        top_toolbar.setNavigationOnClickListener {
            if (presenter.currentScreen().isPresent && presenter.curre
ntScreen().get() == ScreenType.MAIN) {
                drawer_layout.openDrawer(Gravity.LEFT)
            } else {
                presenter.onBack()
            }
        }
        drawer_layout.addDrawerListener(toggle)
        if (savedInstanceState != null) {
            presenter.doNotResetNavigationStack()
        }
        presenter.attachView(this)
    }
    override fun onDestroy() {
        presenter.detachView(this)
        super.onDestroy()
    }
    override fun onBackPressed() {
        presenter.onBack()
    }
    override fun close() {
        finish()
    }
    override fun getPermissions(permissions: Array<String>) {
        requestPermissions(permissions, PERMISSION_REQUEST)
    }
    override fun onRequestPermissionsResult(
        requestCode: Int,
        permissions: Array<out String>,
        grantResults: IntArray
    ) {
        super.onRequestPermissionsResult(requestCode, permissions, gra
ntResults)
        if (requestCode == PERMISSION_REQUEST) {
            presenter.onResult(grantResults.all { it == 0 })
        }
    }
    override fun open(screen: ScreenType) {
        navigateToFragment(screenMapper.fragmentByScreenType(screen))
    }
    fun setDrawerEnabled(enabled: Boolean) {
        val mode = if (enabled) {
            DrawerLayout.LOCK_MODE_UNLOCKED
        } else {
            DrawerLayout.LOCK_MODE_LOCKED_CLOSED
        }
        drawer_layout.setDrawerLockMode(mode)
    }
    private fun navigateToFragment(fragment: Fragment) {
        supportFragmentManager.beginTransaction()
            .replace(R.id.root_layout, fragment)
            .commit()
    }
    private fun overrideStatusBarColor() {
        window.apply {
            addFlags(WindowManager.LayoutParams.FLAG_DRAWS_SYSTEM_BAR_
BACKGROUNDS)
            clearFlags(WindowManager.LayoutParams.FLAG_TRANSLUCENT_STA
TUS)
            statusBarColor = ContextCompat.getColor(context, R.color.s
tatus_bar)
        }
    }
}
\end{verbatim}

\subsection{MainFragment.kt}
\begin{verbatim}
package com.closecom.app.ui
import android.os.Bundle
import android.view.View
import com.closecom.R
import com.closecom.app.domain.model.ScreenType
import com.closecom.app.ui.common.fragments.BaseFragment
import kotlinx.android.synthetic.main.main_fragment_layout.*
class MainFragment : BaseFragment(R.layout.main_fragment_layout) {
    override val screenType = ScreenType.MAIN
    override fun onViewCreated(view: View, savedInstanceState: Bundle?
) {
        super.onViewCreated(view, savedInstanceState)
        setupActionBar()
        layout_refresh.setOnRefreshListener {
            view_chat_list.presenter.onChatsRefresh {
                layout_refresh.isRefreshing = false
            }
        }
    }
    private fun setupActionBar() {
        actionBar().title = context!!.getString(R.string.action_bar_ch
ats_list_title)
    }
}
\end{verbatim}

\subsection{SettingsMenuModelFactory.kt}
\begin{verbatim}
package com.closecom.app.ui.settings
import com.closecom.R
import com.closecom.app.domain.repo.SettingsGateway
import com.closecom.app.domain.repo.auth.AuthGateway
import com.closecom.app.ui.common.menu.MenuModel
import com.closecom.app.ui.common.menu.MenuModelFactory
import javax.inject.Inject
class SettingsMenuModelFactory @Inject constructor(
    private val builder: MenuModel.Builder,
    private val authGateway: AuthGateway,
    private val settingsGateway: SettingsGateway
) : MenuModelFactory {
    override fun createMenuModel(): MenuModel {
        return builder.run {
            addButtonCell(R.string.settings_logout) { authGateway.rese
t() }
            addSwitcherCell(
                R.string.settings_dark_theme,
                settingsGateway.nightMode
            ) {
                settingsGateway.nightMode = it
            }
            addButtonCell(
                R.string.settings_delete_account
            ) {
                authGateway.run {
                    deleteAccount()
                    reset()
                }
            }
            build()
        }
    }
}
\end{verbatim}

\subsection{SettingsFragment.kt}
\begin{verbatim}
package com.closecom.app.ui.settings
import android.os.Bundle
import android.view.View
import androidx.recyclerview.widget.LinearLayoutManager
import com.closecom.R
import com.closecom.app.di.AppSdk
import com.closecom.app.domain.model.ScreenType
import com.closecom.app.ui.common.decorators.ListItemDecorator
import com.closecom.app.ui.common.fragments.BaseFragment
import com.closecom.app.ui.common.menu.MenuAdaptersFactory
import javax.inject.Inject
import kotlinx.android.synthetic.main.settings_fragment_layout.*
class SettingsFragment : BaseFragment(R.layout.settings_fragment_layou
t) {
    @Inject
    lateinit var adaptersFactory: MenuAdaptersFactory
    override val screenType = ScreenType.SETTINGS
    override fun onViewCreated(view: View, savedInstanceState: Bundle?
) {
        super.onViewCreated(view, savedInstanceState)
        AppSdk.appComponent.inject(this)
        setupActionBar()
        recycler_view_settings.apply {
            adapter = adaptersFactory.createSettingsMenuAdapter()
            layoutManager = LinearLayoutManager(context)
            addItemDecoration(ListItemDecorator(context))
        }
    }
    private fun setupActionBar() {
        actionBar().title = context!!.getString(R.string.action_bar_se
ttings_title)
    }
}
\end{verbatim}

\subsection{DevMenuModelFactory.kt}
\begin{verbatim}
package com.closecom.app.ui.develop
import com.closecom.R
import com.closecom.app.ui.common.menu.MenuModel
import com.closecom.app.ui.common.menu.MenuModelFactory
import com.closecom.develop.domain.repo.DevSettingsGateway
import javax.inject.Inject
class DevMenuModelFactory @Inject constructor(
    private val builder: MenuModel.Builder,
    private val settings: DevSettingsGateway
) : MenuModelFactory {
    override fun createMenuModel(): MenuModel {
        return builder.run {
            addSwitcherCell(
                R.string.develop_mock_api_title,
                settings.mockApi
            ) {
                settings.mockApi = it
            }
            addSwitcherCell(
                R.string.develop_auto_login,
                settings.autoLogin
            ) {
                settings.autoLogin = it
            }
            addSwitcherCell(
                R.string.develop_empty_chats,
                settings.emptyChatsList
            ) {
                settings.emptyChatsList = it
            }
            addButtonCell(R.string.develop_reset_settings) {
                settings.reset()
            }
            build()
        }
    }
}
\end{verbatim}

\subsection{DevelopFragment.kt}
\begin{verbatim}
package com.closecom.app.ui.develop
import android.os.Bundle
import android.view.View
import androidx.recyclerview.widget.LinearLayoutManager
import com.closecom.R
import com.closecom.app.di.AppSdk
import com.closecom.app.domain.model.ScreenType
import com.closecom.app.ui.common.decorators.ListItemDecorator
import com.closecom.app.ui.common.fragments.BaseFragment
import com.closecom.app.ui.common.menu.MenuAdaptersFactory
import javax.inject.Inject
import kotlinx.android.synthetic.main.develop_fragment_layout.*
class DevelopFragment : BaseFragment(R.layout.develop_fragment_layout)
 {
    override val screenType = ScreenType.DEVELOP
    @Inject
    lateinit var adaptersFactory: MenuAdaptersFactory
    override fun onViewCreated(view: View, savedInstanceState: Bundle?
) {
        super.onViewCreated(view, savedInstanceState)
        AppSdk.appComponent.inject(this)
        recycler_view_dev.apply {
            adapter = adaptersFactory.createDevSettingsAdapter()
            layoutManager = LinearLayoutManager(context)
            addItemDecoration(ListItemDecorator(context))
        }
    }
}
\end{verbatim}

\subsection{ChatFragment.kt}
\begin{verbatim}
package com.closecom.app.ui.chat
import android.os.Bundle
import android.view.View
import com.arellomobile.mvp.presenter.InjectPresenter
import com.closecom.R
import com.closecom.app.di.AppSdk
import com.closecom.app.domain.model.ScreenType
import com.closecom.app.ui.common.fragments.BaseFragment
import javax.inject.Inject
import kotlinx.android.synthetic.main.chat_fragment_layout.*
class ChatFragment : BaseFragment(R.layout.chat_fragment_layout), Chat
View {
    override val screenType = ScreenType.CHAT
    @Inject
    @InjectPresenter
    lateinit var presenter: ChatPresenter
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        AppSdk.appComponent.inject(this)
        presenter.attachView(this)
    }
    override fun onDestroy() {
        presenter.detachView(this)
        super.onDestroy()
    }
    override fun onViewCreated(view: View, savedInstanceState: Bundle?
) {
        super.onViewCreated(view, savedInstanceState)
        button_send_message.setOnClickListener {
            presenter.onSendMessage(edit_chat_message.text.toString())
        }
    }
    override fun onMessageSent() {
        edit_chat_message.text!!.apply { delete(0, length) }
    }
    override fun setActionBarTitle(title: String) {
        actionBar().title = title
    }
}
\end{verbatim}

\subsection{ChatPresenter.kt}
\begin{verbatim}
package com.closecom.app.ui.chat
import com.arellomobile.mvp.InjectViewState
import com.arellomobile.mvp.MvpPresenter
import com.closecom.app.domain.repo.messanger.ActiveChatGateway
import io.reactivex.rxjava3.android.schedulers.AndroidSchedulers
import io.reactivex.rxjava3.disposables.CompositeDisposable
import javax.inject.Inject
@InjectViewState
class ChatPresenter @Inject constructor(
    private val activeChatGateway: ActiveChatGateway
) : MvpPresenter<ChatView>() {
    private val compositeDisposable = CompositeDisposable()
    override fun onFirstViewAttach() {
        super.onFirstViewAttach()
        compositeDisposable.add(
            activeChatGateway.activeChat()
                .subscribeOn(AndroidSchedulers.mainThread())
                .observeOn(AndroidSchedulers.mainThread())
                .filter { it.isPresent }
                .map { it.get() }
                .subscribe {
                    viewState.setActionBarTitle(it.name)
                }
        )
    }
    fun onSendMessage(text: String) {
        if (text.isBlank()) return
        viewState.onMessageSent()
        activeChatGateway.sendMessage(text)
    }
}
\end{verbatim}

\subsection{ChatView.kt}
\begin{verbatim}
package com.closecom.app.ui.chat
import com.arellomobile.mvp.MvpView
interface ChatView : MvpView {
    fun onMessageSent()
    fun setActionBarTitle(title: String)
}
\end{verbatim}

\subsection{MessageListViewImpl.kt}
\begin{verbatim}
package com.closecom.app.ui.chat.message_list
import android.content.Context
import android.util.AttributeSet
import android.view.View
import androidx.constraintlayout.widget.ConstraintLayout
import androidx.recyclerview.widget.LinearLayoutManager
import com.arellomobile.mvp.presenter.InjectPresenter
import com.closecom.R
import com.closecom.app.di.AppSdk
import javax.inject.Inject
import kotlinx.android.synthetic.main.message_list_body.view.*
class MessageListViewImpl(
    context: Context,
    attributeSet: AttributeSet
) : ConstraintLayout(context, attributeSet),
    MessageListView {
    @InjectPresenter
    @Inject
    lateinit var presenter: MessageListPresenter
    init {
        AppSdk.appComponent.inject(this)
        View.inflate(context, R.layout.message_list_body, this)
        recycler_messages_list.apply {
            layoutManager = LinearLayoutManager(context).apply { stack
FromEnd = true }
            adapter = presenter.messageListAdapter()
        }
    }
    override fun onAttachedToWindow() {
        super.onAttachedToWindow()
        presenter.attachView(this)
    }
    override fun onDetachedFromWindow() {
        presenter.detachView(this)
        super.onDetachedFromWindow()
    }
}
\end{verbatim}

\subsection{MessageListPresenter.kt}
\begin{verbatim}
package com.closecom.app.ui.chat.message_list
import com.arellomobile.mvp.InjectViewState
import com.arellomobile.mvp.MvpPresenter
import com.closecom.app.domain.repo.messanger.ActiveChatGateway
import com.closecom.app.ui.chat.message_list.adapter.MessageListAdapte
r
import io.reactivex.rxjava3.android.schedulers.AndroidSchedulers
import io.reactivex.rxjava3.disposables.CompositeDisposable
import javax.inject.Inject
@InjectViewState
class MessageListPresenter @Inject constructor(
    private val activeChatGateway: ActiveChatGateway,
    private val messageListAdapter: MessageListAdapter
) : MvpPresenter<MessageListView>() {
    private val subscription = CompositeDisposable()
    override fun onFirstViewAttach() {
        super.onFirstViewAttach()
        messageListAdapter.isLoading = true
        subscription.add(
            activeChatGateway.messages()
                .subscribeOn(AndroidSchedulers.mainThread())
                .observeOn(AndroidSchedulers.mainThread())
                .subscribe {
                    messageListAdapter.messages = it
                }
        )
        subscription.add(
            activeChatGateway.isFakeChat()
                .subscribeOn(AndroidSchedulers.mainThread())
                .subscribeOn(AndroidSchedulers.mainThread())
                .subscribe {
                    messageListAdapter.isStart = it
                }
        )
        activeChatGateway.updateMessages()
    }
    fun messageListAdapter() = messageListAdapter
}
\end{verbatim}

\subsection{MessageListView.kt}
\begin{verbatim}
package com.closecom.app.ui.chat.message_list
import com.arellomobile.mvp.MvpView
interface MessageListView : MvpView
\end{verbatim}

\subsection{MessageListAdapter.kt}
\begin{verbatim}
package com.closecom.app.ui.chat.message_list.adapter
import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import androidx.recyclerview.widget.RecyclerView
import com.closecom.R
import com.closecom.app.api.domain.model.Message
import com.closecom.app.ui.chat.message_list.message_cell.MessageCellV
iewImpl
import javax.inject.Inject
private enum class Cell {
    MESSAGE,
    EMPTY,
    START,
    LOADING
}
class MessageListAdapter @Inject constructor() :
    RecyclerView.Adapter<MessageListAdapter.MessageViewHolder>() {
    var isStart = false
        set(value) {
            if (field != value) {
                field = value
                notifyDataSetChanged()
            }
        }
    var isLoading = false
        set(value) {
            if (field != value) {
                field = value
                notifyDataSetChanged()
            }
        }
    var messages: List<Message> = emptyList()
        set(value) {
            field = value
            notifyDataSetChanged()
        }
    override fun onCreateViewHolder(
        parent: ViewGroup,
        viewType: Int
    ): MessageViewHolder {
        val res = when (Cell.values()[viewType]) {
            Cell.LOADING -> R.layout.message_cell_loading
            Cell.MESSAGE -> R.layout.message_cell
            Cell.START -> R.layout.message_cell_start
            Cell.EMPTY -> R.layout.message_cell_empty
        }
        val view = LayoutInflater.from(parent.context)
            .inflate(res, parent, false)
        return MessageViewHolder(view)
    }
    override fun getItemCount(): Int {
        return if (messages.isEmpty()) 1 else messages.size
    }
    override fun getItemViewType(position: Int): Int {
        return when {
            isStart -> Cell.START
            isLoading && messages.isEmpty() -> Cell.LOADING
            messages.isNotEmpty() -> Cell.MESSAGE
            else -> Cell.EMPTY
        }.ordinal
    }
    override fun onBindViewHolder(holder: MessageViewHolder, position:
 Int) {
        holder.messageCell?.run {
            setMessage(messages[position])
        }
    }
    class MessageViewHolder(view: View) : RecyclerView.ViewHolder(view
) {
        val messageCell: MessageCellViewImpl? = view as? MessageCellVi
ewImpl
    }
}
\end{verbatim}

\subsection{MessageCellViewImpl.kt}
\begin{verbatim}
package com.closecom.app.ui.chat.message_list.message_cell
import android.content.Context
import android.util.AttributeSet
import android.view.Gravity
import android.view.View
import android.widget.FrameLayout
import androidx.core.content.ContextCompat
import androidx.core.view.isVisible
import com.arellomobile.mvp.presenter.InjectPresenter
import com.closecom.R
import com.closecom.app.api.domain.model.Message
import com.closecom.app.di.AppSdk
import com.closecom.app.domain.model.MessageAnchor
import com.closecom.app.domain.model.MessageCellData
import javax.inject.Inject
import kotlinx.android.synthetic.main.message_cell_body.view.*
import kotlinx.android.synthetic.main.message_view_body.view.*
class MessageCellViewImpl(
    context: Context,
    attributeSet: AttributeSet
) : FrameLayout(context, attributeSet),
    MessageCellView {
    @Inject
    @InjectPresenter
    lateinit var presenter: MessageCellPresenter
    init {
        AppSdk.appComponent.inject(this)
        View.inflate(context, R.layout.message_cell_body, this)
    }
    override fun onAttachedToWindow() {
        super.onAttachedToWindow()
        presenter.attachView(this)
    }
    override fun onDetachedFromWindow() {
        presenter.destroyView(this)
        super.onDetachedFromWindow()
    }
    override fun setMessageData(data: MessageCellData) {
        view_message.text_message.text = data.text
        view_message.text_date.text = data.date
        setMessageAnchor(data.anchor)
    }
    fun setMessage(message: Message) {
        presenter.setMessage(message)
    }
    private fun setMessageAnchor(anchor: MessageAnchor) {
        val isLeft = anchor == MessageAnchor.LEFT
        val params = LayoutParams(LayoutParams.WRAP_CONTENT, LayoutPar
ams.WRAP_CONTENT)
        params.gravity = if (isLeft) Gravity.START else Gravity.END
        val backgroundColor =
            if (isLeft) R.color.left_message_color else R.color.right_
message_color
        view_message.apply {
            view_message.layoutParams = params
            view_message.background.setTint(ContextCompat.getColor(con
text, backgroundColor))
            view_message.isVisible = true
        }
    }
}
\end{verbatim}

\subsection{MessageCellView.kt}
\begin{verbatim}
package com.closecom.app.ui.chat.message_list.message_cell
import com.arellomobile.mvp.MvpView
import com.closecom.app.domain.model.MessageCellData
interface MessageCellView : MvpView {
    fun setMessageData(data: MessageCellData)
}
\end{verbatim}

\subsection{MessageCellPresenter.kt}
\begin{verbatim}
package com.closecom.app.ui.chat.message_list.message_cell
import com.arellomobile.mvp.InjectViewState
import com.arellomobile.mvp.MvpPresenter
import com.closecom.app.api.domain.model.Message
import com.closecom.app.domain.usecase.MessageToMessageCellMapper
import javax.inject.Inject
@InjectViewState
class MessageCellPresenter @Inject constructor(
    private val messageToMessageCellMapper: MessageToMessageCellMapper
) : MvpPresenter<MessageCellView>() {
    fun setMessage(message: Message) {
        viewState.setMessageData(messageToMessageCellMapper(message))
    }
}
\end{verbatim}

\subsection{MessageView.kt}
\begin{verbatim}
package com.closecom.app.ui.chat.message_list.message_view
import com.arellomobile.mvp.MvpView
interface MessageView : MvpView
\end{verbatim}

\subsection{MessageViewImpl.kt}
\begin{verbatim}
package com.closecom.app.ui.chat.message_list.message_view
import android.content.Context
import android.util.AttributeSet
import android.view.View
import androidx.constraintlayout.widget.ConstraintLayout
import com.closecom.R
class MessageViewImpl(
    context: Context,
    attributeSet: AttributeSet
) : ConstraintLayout(context, attributeSet),
    MessageView {
    init {
        View.inflate(context, R.layout.message_view_body, this)
    }
}
\end{verbatim}

\subsection{AuthFragment.kt}
\begin{verbatim}
package com.closecom.app.ui.auth
import android.app.AlertDialog
import android.os.Bundle
import android.view.View
import androidx.core.widget.addTextChangedListener
import com.arellomobile.mvp.presenter.InjectPresenter
import com.closecom.R
import com.closecom.app.di.AppSdk
import com.closecom.app.domain.model.ScreenType
import com.closecom.app.ui.MainActivity
import com.closecom.app.ui.common.fragments.BaseFragment
import javax.inject.Inject
import kotlinx.android.synthetic.main.auth_fragment_layout.*
class AuthFragment : BaseFragment(R.layout.auth_fragment_layout), Auth
View {
    @Inject
    @InjectPresenter
    lateinit var presenter: AuthPresenter
    override val screenType = ScreenType.AUTH
    override fun onViewCreated(view: View, savedInstanceState: Bundle?
) {
        super.onViewCreated(view, savedInstanceState)
        AppSdk.appComponent.inject(this)
        (activity as MainActivity).supportActionBar!!.hide()
        edit_email.addTextChangedListener { presenter.setEmail(it.toSt
ring()) }
        edit_password.addTextChangedListener { presenter.setPassword(i
t.toString()) }
        button_sign_in.setOnClickListener { presenter.onSignIn() }
        button_sign_up.setOnClickListener { presenter.onSignUp() }
        button_forgot_password.setOnClickListener { presenter.onForgot
Password() }
        text_closecom.setOnClickListener { presenter.onDevelopClick() 
}
        presenter.attachView(this)
    }
    override fun onDestroyView() {
        presenter.destroyView(this)
        super.onDestroyView()
    }
    override fun showAlert(titleId: Int, descriptionId: Int) {
        AlertDialog.Builder(context).apply {
            setTitle(context.resources.getString(titleId))
            setMessage(context.resources.getString(descriptionId))
            setPositiveButton(context.resources.getString(R.string.aut
h_dialog_confirm)) { dialog, _ ->
                dialog.cancel()
            }
        }.create().show()
    }
}
\end{verbatim}

\subsection{AuthPresenter.kt}
\begin{verbatim}
package com.closecom.app.ui.auth
import com.arellomobile.mvp.InjectViewState
import com.arellomobile.mvp.MvpPresenter
import com.closecom.R
import com.closecom.app.api.data.repo.mvp.MOCK_EMAIL
import com.closecom.app.api.data.repo.mvp.MOCK_PASSWORD
import com.closecom.app.domain.model.AuthInfo
import com.closecom.app.domain.model.ScreenType
import com.closecom.app.domain.repo.NavigationGateway
import com.closecom.app.domain.repo.auth.AuthGateway
import com.closecom.app.domain.usecase.AuthInfoValidationUseCase
import com.closecom.app.domain.usecase.SignInUseCase
import com.closecom.develop.domain.repo.DevSettingsGateway
import io.reactivex.rxjava3.android.schedulers.AndroidSchedulers
import io.reactivex.rxjava3.disposables.CompositeDisposable
import javax.inject.Inject
@InjectViewState
class AuthPresenter @Inject constructor(
    private val authInfoValidationUseCase: AuthInfoValidationUseCase,
    private val authGateway: AuthGateway,
    private val navigationGateway: NavigationGateway,
    private val signInUseCard: SignInUseCase,
    private val devSettingsGateway: DevSettingsGateway
) : MvpPresenter<AuthView>() {
    private var email = ""
    private var password = ""
    private val compositeDisposable = CompositeDisposable()
    private var developClickCounter = 0
    override fun onFirstViewAttach() {
        compositeDisposable.add(
            authGateway.authorized()
                .subscribeOn(AndroidSchedulers.mainThread())
                .observeOn(AndroidSchedulers.mainThread())
                .filter { it }
                .subscribe { navigationGateway.openScreenWithReset(Scr
eenType.MAIN) }
        )
        if (devSettingsGateway.autoLogin) {
            signInUseCard(MOCK_EMAIL, MOCK_PASSWORD)
        }
    }
    fun setEmail(email: String) {
        this.email = email
    }
    fun setPassword(password: String) {
        this.password = password
    }
    fun onSignIn() {
        if (!signInUseCard(email, password)) {
            viewState.showAlert(
                R.string.auth_dialog_validation_error_title,
                R.string.auth_dialog_validation_error_description
            )
        }
    }
    fun onSignUp() {
        val info = AuthInfo(email, password)
        if (authInfoValidationUseCase.isInfoValid(info)) {
            authGateway.createAccount(info)
        } else {
            viewState.showAlert(
                R.string.auth_dialog_validation_error_title,
                R.string.auth_dialog_validation_error_description
            )
        }
    }
    fun onForgotPassword() {
        if (authInfoValidationUseCase.isEmailValid(email)) {
            authGateway.passwordRecovery(email)
        } else {
            viewState.showAlert(
                R.string.auth_dialog_validation_error_email_title,
                R.string.auth_dialog_validation_error_description
            )
        }
    }
    fun onDevelopClick() {
        if (++developClickCounter == 5) {
            developClickCounter = 0
            navigationGateway.openScreen(ScreenType.DEVELOP)
        }
    }
}
\end{verbatim}

\subsection{AuthView.kt}
\begin{verbatim}
package com.closecom.app.ui.auth
import androidx.annotation.StringRes
import com.arellomobile.mvp.MvpView
interface AuthView : MvpView {
    fun showAlert(@StringRes titleId: Int, @StringRes descriptionId: I
nt)
}
\end{verbatim}

\subsection{ChatListPresenter.kt}
\begin{verbatim}
package com.closecom.app.ui.chat_list
import android.util.Log
import com.arellomobile.mvp.InjectViewState
import com.arellomobile.mvp.MvpPresenter
import com.closecom.app.domain.repo.BluetoothGateway
import com.closecom.app.domain.repo.PermissionGateway
import com.closecom.app.domain.repo.messanger.ChatsGateway
import com.closecom.app.ui.chat_list.adapter.ChatListAdapter
import io.reactivex.rxjava3.android.schedulers.AndroidSchedulers
import io.reactivex.rxjava3.disposables.CompositeDisposable
import javax.inject.Inject
@InjectViewState
class ChatListPresenter @Inject constructor(
    private val chatsGateway: ChatsGateway,
    private val chatListAdapter: ChatListAdapter,
    private val bluetoothGateway: BluetoothGateway,
    private val permissionGateway: PermissionGateway
) : MvpPresenter<ChatListView>() {
    private val subscriptions = CompositeDisposable()
    override fun onFirstViewAttach() {
        super.onFirstViewAttach()
        subscriptions.add(
            chatsGateway.chats()
                .subscribeOn(AndroidSchedulers.mainThread())
                .observeOn(AndroidSchedulers.mainThread())
                .subscribe {
                    chatListAdapter.setChats(it)
                    viewState.setLoading(false)
                }
        )
        if (!permissionGateway.hasPermissions(permissionGateway.blueto
othPermissions())) {
            permissionGateway.requestPermission(permissionGateway.blue
toothPermissions())
        }
        Log.d("ChatPresenter", "bluetoothGateway.trySetBid()")
        bluetoothGateway.trySetBid()
    }
    fun onChatsRefresh(onUpdated: () -> Unit) {
        chatsGateway.updateChats(onUpdated)
    }
    fun chatListAdapter() = chatListAdapter
}
\end{verbatim}

\subsection{ChatListView.kt}
\begin{verbatim}
package com.closecom.app.ui.chat_list
import com.arellomobile.mvp.MvpView
interface ChatListView : MvpView {
    fun setLoading(isLoading: Boolean)
}
\end{verbatim}

\subsection{ChatListViewImpl.kt}
\begin{verbatim}
package com.closecom.app.ui.chat_list
import android.content.Context
import android.util.AttributeSet
import android.view.View
import androidx.constraintlayout.widget.ConstraintLayout
import androidx.core.view.isVisible
import androidx.recyclerview.widget.LinearLayoutManager
import com.arellomobile.mvp.presenter.InjectPresenter
import com.closecom.R
import com.closecom.app.di.AppSdk
import com.closecom.app.ui.common.decorators.ListItemDecorator
import javax.inject.Inject
import kotlinx.android.synthetic.main.chat_list_body.view.*
class ChatListViewImpl(
    context: Context,
    attributeSet: AttributeSet
) : ConstraintLayout(context, attributeSet),
    ChatListView {
    @Inject
    @InjectPresenter
    lateinit var presenter: ChatListPresenter
    init {
        AppSdk.appComponent.inject(this)
        View.inflate(context, R.layout.chat_list_body, this)
        recycler_chat_list.apply {
            adapter = presenter.chatListAdapter()
            layoutManager = LinearLayoutManager(context)
            addItemDecoration(ListItemDecorator(context))
        }
    }
    override fun onAttachedToWindow() {
        super.onAttachedToWindow()
        presenter.attachView(this)
    }
    override fun onDetachedFromWindow() {
        presenter.detachView(this)
        super.onDetachedFromWindow()
    }
    override fun setLoading(isLoading: Boolean) {
        progress_bar.isVisible = isLoading
        recycler_chat_list.isVisible = !isLoading
    }
}
\end{verbatim}

\subsection{ChatCellView.kt}
\begin{verbatim}
package com.closecom.app.ui.chat_list.chat_cell
import com.arellomobile.mvp.MvpView
import com.closecom.app.domain.model.ChatCellData
interface ChatCellView : MvpView {
    fun setChatCellData(data: ChatCellData)
}
\end{verbatim}

\subsection{ChatCellPresenter.kt}
\begin{verbatim}
package com.closecom.app.ui.chat_list.chat_cell
import com.arellomobile.mvp.InjectViewState
import com.arellomobile.mvp.MvpPresenter
import com.closecom.app.api.domain.model.Chat
import com.closecom.app.domain.usecase.ChatToCellDataMapper
import com.closecom.app.domain.usecase.OpenChatScreenUseCase
import javax.inject.Inject
@InjectViewState
class ChatCellPresenter @Inject constructor(
    private val chatToCellDataMapper: ChatToCellDataMapper,
    private val openChatScreenUseCase: OpenChatScreenUseCase
) : MvpPresenter<ChatCellView>() {
    private lateinit var chat: Chat
    fun setChatData(chat: Chat) {
        this.chat = chat
        viewState.setChatCellData(chatToCellDataMapper(chat))
    }
    fun onClick() {
        openChatScreenUseCase.execute(chat)
    }
}
\end{verbatim}

\subsection{ChatCellViewImpl.kt}
\begin{verbatim}
package com.closecom.app.ui.chat_list.chat_cell
import android.content.Context
import android.util.AttributeSet
import android.view.View
import androidx.constraintlayout.widget.ConstraintLayout
import com.arellomobile.mvp.presenter.InjectPresenter
import com.closecom.R
import com.closecom.app.api.domain.model.Chat
import com.closecom.app.di.AppSdk
import com.closecom.app.domain.model.ChatCellData
import javax.inject.Inject
import kotlinx.android.synthetic.main.chat_cell_body.view.*
class ChatCellViewImpl(
    context: Context,
    attributeSet: AttributeSet
) : ConstraintLayout(context, attributeSet),
    ChatCellView {
    @Inject
    @InjectPresenter
    lateinit var presenter: ChatCellPresenter
    init {
        AppSdk.appComponent.inject(this)
        View.inflate(context, R.layout.chat_cell_body, this)
        setOnClickListener { presenter.onClick() }
    }
    override fun onAttachedToWindow() {
        super.onAttachedToWindow()
        presenter.attachView(this)
    }
    override fun onDetachedFromWindow() {
        presenter.detachView(this)
        super.onDetachedFromWindow()
    }
    override fun setChatCellData(data: ChatCellData) {
        text_description.text = data.description
        text_title.text = data.title
        text_date.text = data.date
    }
    fun setChat(chat: Chat) {
        presenter.setChatData(chat)
    }
}
\end{verbatim}

\subsection{ChatListAdapter.kt}
\begin{verbatim}
package com.closecom.app.ui.chat_list.adapter
import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import androidx.recyclerview.widget.RecyclerView
import com.closecom.R
import com.closecom.app.api.domain.model.Chat
import com.closecom.app.ui.chat_list.chat_cell.ChatCellViewImpl
import javax.inject.Inject
private const val CHAT_CELL = 1
private const val EMPTY_THRESHOLD = 0
class ChatListAdapter @Inject constructor() :
    RecyclerView.Adapter<ChatListAdapter.ChatViewHolder>() {
    private var chats: List<Chat> = emptyList()
    fun setChats(chats: List<Chat>) {
        this.chats = chats
        notifyDataSetChanged()
    }
    override fun onCreateViewHolder(
        parent: ViewGroup,
        viewType: Int
    ): ChatViewHolder {
        val res = when (viewType) {
            CHAT_CELL -> R.layout.chat_cell
            else -> R.layout.empty_cell_view
        }
        val view = LayoutInflater.from(parent.context).inflate(res, pa
rent, false)
        return ChatViewHolder(view)
    }
    override fun getItemCount(): Int {
        return if (chats.isNotEmpty()) chats.size else 1
    }
    override fun getItemViewType(position: Int): Int {
        return if (position == 0 && chats.isEmpty()) {
            EMPTY_THRESHOLD
        } else {
            CHAT_CELL
        }
    }
    override fun onBindViewHolder(holder: ChatViewHolder, position: In
t) {
        if (holder.chatCellView != null) {
            val chat = chats[position]
            holder.chatCellView.setChat(chat)
        }
    }
    class ChatViewHolder(view: View) : RecyclerView.ViewHolder(view) {
        val chatCellView: ChatCellViewImpl? = view as? ChatCellViewImp
l
    }
}
\end{verbatim}

\subsection{EmptyCellView.kt}
\begin{verbatim}
package com.closecom.app.ui.chat_list.empty_cell
import android.content.Context
import android.util.AttributeSet
import android.view.View
import androidx.constraintlayout.widget.ConstraintLayout
import com.closecom.R
class EmptyCellView(
    context: Context,
    attributeSet: AttributeSet
) : ConstraintLayout(context, attributeSet) {
    init {
        View.inflate(context, R.layout.empty_cell_view_body, this)
    }
}
\end{verbatim}

\subsection{SlideMenuView.kt}
\begin{verbatim}
package com.closecom.app.ui.slide_menu
import com.arellomobile.mvp.MvpView
interface SlideMenuView : MvpView {
    fun setTitle(title: String)
}
\end{verbatim}

\subsection{SlideMenuModelFactory.kt}
\begin{verbatim}
package com.closecom.app.ui.slide_menu
import com.closecom.R
import com.closecom.app.domain.model.ScreenType
import com.closecom.app.domain.repo.NavigationGateway
import com.closecom.app.ui.common.menu.MenuModel
import com.closecom.app.ui.common.menu.MenuModelFactory
import javax.inject.Inject
class SlideMenuModelFactory @Inject constructor(
    private val builder: MenuModel.Builder,
    private val navigationGateway: NavigationGateway
) : MenuModelFactory {
    override fun createMenuModel(): MenuModel {
        return builder.run {
            addButtonCell(R.string.slide_menu_user_search) {
                navigationGateway.openScreen(ScreenType.SEARCH)
            }
            addButtonCell(R.string.slide_menu_bluetooth_search) {
                navigationGateway.openScreen(ScreenType.BLUETOOTH)
            }
            addButtonCell(R.string.settings_settings_title) {
                navigationGateway.openScreen(ScreenType.SETTINGS)
            }
//            addButtonCell(R.string.slide_menu_dev_settings) {
//                navigationGateway.openScreen(ScreenType.DEVELOP)
//            }
            build()
        }
    }
}
\end{verbatim}

\subsection{SlideMenuViewImpl.kt}
\begin{verbatim}
package com.closecom.app.ui.slide_menu
import android.content.Context
import android.util.AttributeSet
import android.view.View
import androidx.constraintlayout.widget.ConstraintLayout
import androidx.recyclerview.widget.LinearLayoutManager
import com.arellomobile.mvp.presenter.InjectPresenter
import com.closecom.R
import com.closecom.app.di.AppSdk
import com.closecom.app.ui.common.decorators.ListItemDecorator
import javax.inject.Inject
import kotlinx.android.synthetic.main.slide_view_body.view.*
class SlideMenuViewImpl(
    context: Context,
    attributeSet: AttributeSet
) : ConstraintLayout(context, attributeSet),
    SlideMenuView {
    @Inject
    @InjectPresenter
    lateinit var presenter: SlideMenuPresenter
    init {
        AppSdk.appComponent.inject(this)
        View.inflate(context, R.layout.slide_view_body, this)
        recycler_slide_list.apply {
            adapter = presenter.createSlideMenuAdapter()
            layoutManager = LinearLayoutManager(context)
            addItemDecoration(ListItemDecorator(context))
        }
    }
    override fun onAttachedToWindow() {
        super.onAttachedToWindow()
        presenter.attachView(this)
    }
    override fun onDetachedFromWindow() {
        presenter.detachView(this)
        super.onDetachedFromWindow()
    }
    override fun setTitle(title: String) {
        text_slide_title.text = title
    }
}
\end{verbatim}

\subsection{SlideMenuPresenter.kt}
\begin{verbatim}
package com.closecom.app.ui.slide_menu
import com.arellomobile.mvp.InjectViewState
import com.arellomobile.mvp.MvpPresenter
import com.closecom.app.domain.repo.auth.AuthGateway
import com.closecom.app.ui.common.menu.MenuAdaptersFactory
import io.reactivex.rxjava3.android.schedulers.AndroidSchedulers
import io.reactivex.rxjava3.disposables.CompositeDisposable
import javax.inject.Inject
@InjectViewState
class SlideMenuPresenter @Inject constructor(
    private val authGateway: AuthGateway,
    private val menuAdaptersFactory: MenuAdaptersFactory
) : MvpPresenter<SlideMenuView>() {
    private val compositeDisposable = CompositeDisposable()
    fun createSlideMenuAdapter() = menuAdaptersFactory.createSlideMenu
Adapter()
    override fun onFirstViewAttach() {
        super.onFirstViewAttach()
        compositeDisposable.add(
            authGateway.emailFlowable()
                .subscribeOn(AndroidSchedulers.mainThread())
                .observeOn(AndroidSchedulers.mainThread())
                .subscribe { viewState.setTitle(it) }
        )
    }
}
\end{verbatim}

\subsection{NavigationPresenter.kt}
\begin{verbatim}
package com.closecom.app.ui.navigation
import com.arellomobile.mvp.InjectViewState
import com.arellomobile.mvp.MvpPresenter
import com.closecom.app.domain.model.ScreenType
import com.closecom.app.domain.repo.NavigationGateway
import com.closecom.app.domain.repo.PermissionGateway
import com.closecom.app.domain.usecase.LaunchUseCase
import com.closecom.app.domain.usecase.NoAuthNavigationUseCase
import io.reactivex.rxjava3.android.schedulers.AndroidSchedulers
import io.reactivex.rxjava3.disposables.CompositeDisposable
import java.util.Optional
import javax.inject.Inject
@InjectViewState
class NavigationPresenter @Inject constructor(
    private val navigationGateway: NavigationGateway,
    private val launchUseCase: LaunchUseCase,
    private val noAuthNavigationUseCase: NoAuthNavigationUseCase,
    private val permissionGateway: PermissionGateway
) : MvpPresenter<NavigationView>() {
    private val compositeDisposable = CompositeDisposable()
    private var withReset = true
    fun doNotResetNavigationStack() {
        withReset = false
    }
    override fun onFirstViewAttach() {
        launchUseCase.execute(withReset)
        compositeDisposable.add(
            navigationGateway.screen()
                .subscribeOn(AndroidSchedulers.mainThread())
                .observeOn(AndroidSchedulers.mainThread())
                .filter { it.isPresent }
                .map { it.get() }
                .subscribe { viewState.open(it) }
        )
        compositeDisposable.add(
            navigationGateway.screen()
                .subscribeOn(AndroidSchedulers.mainThread())
                .observeOn(AndroidSchedulers.mainThread())
                .filter { !it.isPresent }
                .subscribe { viewState.close() }
        )
        compositeDisposable.add(
            noAuthNavigationUseCase.execute()
                .subscribeOn(AndroidSchedulers.mainThread())
                .observeOn(AndroidSchedulers.mainThread())
                .subscribe { navigationGateway.openScreenWithReset(Scr
eenType.AUTH) }
        )
        compositeDisposable.add(
            permissionGateway.permission()
                .subscribeOn(AndroidSchedulers.mainThread())
                .observeOn(AndroidSchedulers.mainThread())
                .subscribe { viewState.getPermissions(it.toTypedArray(
)) }
        )
    }
    fun onBack() {
        navigationGateway.navigateBack()
    }
    fun onResult(isSuccess: Boolean) {
        permissionGateway.onResult(isSuccess)
    }
    fun currentScreen(): Optional<ScreenType> {
        return navigationGateway.screenSync()
    }
}
\end{verbatim}

\subsection{NavigationView.kt}
\begin{verbatim}
package com.closecom.app.ui.navigation
import com.arellomobile.mvp.MvpView
import com.closecom.app.domain.model.ScreenType
interface NavigationView : MvpView {
    fun open(screen: ScreenType)
    fun close()
    fun getPermissions(permissions: Array<String>)
}
\end{verbatim}

\subsection{SearchViewImpl.kt}
\begin{verbatim}
package com.closecom.app.ui.search
import android.content.Context
import android.util.AttributeSet
import android.view.View
import androidx.constraintlayout.widget.ConstraintLayout
import androidx.core.widget.doOnTextChanged
import androidx.recyclerview.widget.LinearLayoutManager
import com.arellomobile.mvp.presenter.InjectPresenter
import com.closecom.R
import com.closecom.app.di.AppSdk
import javax.inject.Inject
import kotlinx.android.synthetic.main.search_body.view.*
class SearchViewImpl(
    context: Context,
    attributeSet: AttributeSet
) : ConstraintLayout(context, attributeSet),
    SearchView {
    @Inject
    @InjectPresenter
    lateinit var presenter: SearchViewPresenter
    init {
        AppSdk.appComponent.inject(this)
        View.inflate(context, R.layout.search_body, this)
        recycler_search_result.apply {
            adapter = presenter.searchAdapter()
            layoutManager = LinearLayoutManager(context)
            addItemDecoration(presenter.itemDecorator(context))
        }
        edit_user_name.doOnTextChanged { _, _, _, _ ->
            searchUser()
        }
    }
    override fun onAttachedToWindow() {
        super.onAttachedToWindow()
        presenter.attachView(this)
    }
    override fun onDetachedFromWindow() {
        presenter.detachView(this)
        super.onDetachedFromWindow()
    }
    fun searchUser() {
        presenter.onUserSearch(edit_user_name.text.toString())
    }
}
\end{verbatim}

\subsection{SearchFragment.kt}
\begin{verbatim}
package com.closecom.app.ui.search
import android.os.Bundle
import android.view.View
import com.closecom.R
import com.closecom.app.domain.model.ScreenType
import com.closecom.app.ui.common.fragments.BaseFragment
import kotlinx.android.synthetic.main.search_fragment_layout.*
class SearchFragment : BaseFragment(R.layout.search_fragment_layout) {
    override val screenType = ScreenType.SEARCH
    override fun onViewCreated(view: View, savedInstanceState: Bundle?
) {
        super.onViewCreated(view, savedInstanceState)
        layout_refresher.setOnRefreshListener {
            view_search.searchUser()
            layout_refresher.isRefreshing = false
        }
    }
}
\end{verbatim}

\subsection{SearchView.kt}
\begin{verbatim}
package com.closecom.app.ui.search
import com.arellomobile.mvp.MvpView
interface SearchView : MvpView
\end{verbatim}

\subsection{SearchViewPresenter.kt}
\begin{verbatim}
package com.closecom.app.ui.search
import android.content.Context
import androidx.recyclerview.widget.RecyclerView
import com.arellomobile.mvp.InjectViewState
import com.arellomobile.mvp.MvpPresenter
import com.closecom.app.domain.repo.SearchUsersGateway
import com.closecom.app.ui.common.decorators.ListItemDecorator
import io.reactivex.rxjava3.android.schedulers.AndroidSchedulers
import io.reactivex.rxjava3.disposables.CompositeDisposable
import javax.inject.Inject
@InjectViewState
class SearchViewPresenter @Inject constructor(
    private val searchAdapter: SearchAdapter,
    private val searchUsersGateway: SearchUsersGateway
) : MvpPresenter<SearchView>() {
    private val compositeDisposable = CompositeDisposable()
    override fun onFirstViewAttach() {
        super.onFirstViewAttach()
        compositeDisposable.add(
            searchUsersGateway.searchResult()
                .subscribeOn(AndroidSchedulers.mainThread())
                .observeOn(AndroidSchedulers.mainThread())
                .subscribe { searchAdapter.setUserData(it) }
        )
        compositeDisposable.add(
            searchUsersGateway.loading()
                .subscribeOn(AndroidSchedulers.mainThread())
                .observeOn(AndroidSchedulers.mainThread())
                .subscribe { searchAdapter.setLoading(it) }
        )
    }
    fun searchAdapter(): SearchAdapter = searchAdapter
    fun itemDecorator(context: Context): RecyclerView.ItemDecoration =
 ListItemDecorator(context)
    fun onUserSearch(pattern: String) {
        searchAdapter.setHint(pattern.isEmpty())
        searchUsersGateway.requestSearch(pattern)
    }
}
\end{verbatim}

\subsection{SearchCellView.kt}
\begin{verbatim}
package com.closecom.app.ui.search
import android.content.Context
import android.util.AttributeSet
import android.view.View
import androidx.constraintlayout.widget.ConstraintLayout
import com.closecom.R
import com.closecom.app.api.domain.model.User
import kotlinx.android.synthetic.main.search_user_cell_body.view.*
class SearchCellView(
    context: Context,
    attributeSet: AttributeSet
) : ConstraintLayout(context, attributeSet) {
    private lateinit var user: User
    init {
        View.inflate(context, R.layout.search_user_cell_body, this)
        setOnClickListener {
        }
    }
    fun setUser(user: User) {
        this.user = user
        text_user_name.text = user.email
    }
}
\end{verbatim}

\subsection{SearchAdapter.kt}
\begin{verbatim}
package com.closecom.app.ui.search
import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import androidx.recyclerview.widget.RecyclerView
import com.closecom.R
import com.closecom.app.api.domain.model.User
import com.closecom.app.domain.usecase.OpenNewDialogUseCase
import javax.inject.Inject
private enum class Cell {
    USER,
    EMPTY_RESULT,
    LOADING,
    HINT
}
class SearchAdapter @Inject constructor(
    private val openNewDialogUseCase: OpenNewDialogUseCase
) : RecyclerView.Adapter<SearchAdapter.ViewHolder>() {
    private var data = emptyList<User>()
    private var loading = false
    private var showHint = true
    fun setUserData(data: List<User>) {
        this.data = data
        notifyDataSetChanged()
    }
    fun setLoading(loading: Boolean) {
        if (this.loading != loading) {
            this.loading = loading
            notifyDataSetChanged()
        }
    }
    fun setHint(hint: Boolean) {
        if (showHint != hint) {
            showHint = hint
            notifyDataSetChanged()
        }
    }
    override fun onCreateViewHolder(parent: ViewGroup, viewType: Int):
 ViewHolder {
        val res = when (Cell.values()[viewType]) {
            Cell.USER -> R.layout.search_user_cell
            Cell.LOADING -> R.layout.search_user_loading
            Cell.HINT -> R.layout.search_user_hint
            Cell.EMPTY_RESULT -> R.layout.search_user_empty
        }
        val view = LayoutInflater.from(parent.context).inflate(res, pa
rent, false)
        return ViewHolder(view)
    }
    override fun getItemCount(): Int {
        return if (data.isNotEmpty()) data.size else 1
    }
    override fun getItemViewType(position: Int): Int {
        return when {
            showHint -> Cell.HINT
            loading -> Cell.LOADING
            data.isEmpty() -> Cell.EMPTY_RESULT
            else -> Cell.USER
        }.ordinal
    }
    override fun onBindViewHolder(holder: ViewHolder, position: Int) {
        holder.userCell?.apply {
            val user = data[position]
            setUser(user)
            setOnClickListener {
                openNewDialogUseCase.execute(user)
            }
        }
    }
    class ViewHolder(view: View) : RecyclerView.ViewHolder(view) {
        val userCell = view as? SearchCellView
    }
}
\end{verbatim}

\subsection{BaseFragment.kt}
\begin{verbatim}
package com.closecom.app.ui.common.fragments
import android.os.Bundle
import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import androidx.annotation.LayoutRes
import androidx.fragment.app.Fragment
import com.closecom.R
import com.closecom.app.di.AppSdk
import com.closecom.app.domain.model.ButtonType
import com.closecom.app.domain.model.ScreenType
import com.closecom.app.domain.repo.mappers.ShowActionBarMapper
import com.closecom.app.ui.MainActivity
import javax.inject.Inject
abstract class BaseFragment(@LayoutRes id: Int) : Fragment(id) {
    @Inject
    lateinit var showActionBarMapper: ShowActionBarMapper
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        AppSdk.appComponent.inject(this)
    }
    override fun onCreateView(
        inflater: LayoutInflater,
        container: ViewGroup?,
        savedInstanceState: Bundle?
    ): View? {
        val type = showActionBarMapper(screenType)
        val icon = when (type.buttonType) {
            ButtonType.HOME -> R.drawable.ic_menu
            else -> R.drawable.ic_arrow_back
        }
        actionBar().run {
            setDisplayHomeAsUpEnabled(type.buttonType != ButtonType.EM
PTY)
            setHomeAsUpIndicator(icon)
            (activity as MainActivity).setDrawerEnabled(type.buttonTyp
e == ButtonType.HOME)
        }
        if (type.buttonType == ButtonType.EMPTY) {
            actionBar().hide()
        } else {
            actionBar().show()
        }
        actionBar().setTitle(type.title)
        return super.onCreateView(inflater, container, savedInstanceSt
ate)
    }
    fun actionBar() = (activity as MainActivity).supportActionBar!!
    abstract val screenType: ScreenType
}
\end{verbatim}

\subsection{ListItemDecorator.kt}
\begin{verbatim}
package com.closecom.app.ui.common.decorators
import android.content.Context
import android.graphics.Canvas
import androidx.core.content.ContextCompat
import androidx.recyclerview.widget.RecyclerView
import com.closecom.R
class ListItemDecorator(context: Context) : RecyclerView.ItemDecoratio
n() {
    private val separator = ContextCompat.getDrawable(context, R.drawa
ble.line_slpitter)!!
    override fun onDraw(c: Canvas, parent: RecyclerView, state: Recycl
erView.State) {
        super.onDraw(c, parent, state)
        val left = parent.paddingLeft
        val right = parent.width - parent.paddingRight
        val childCount = parent.childCount
        for (i in 0 until childCount) {
            val child = parent.getChildAt(i)
            val params = child.layoutParams as RecyclerView.LayoutPara
ms
            val top = child.bottom + params.bottomMargin
            val bottom = top + separator.intrinsicHeight
            separator.setBounds(left, top, right, bottom)
            separator.draw(c)
        }
    }
}
\end{verbatim}

\subsection{MenuAdapter.kt}
\begin{verbatim}
package com.closecom.app.ui.common.menu
import android.view.LayoutInflater
import android.view.ViewGroup
import androidx.recyclerview.widget.RecyclerView
import com.closecom.R
class MenuAdapter constructor(
    menuModelFactory: MenuModelFactory
) : RecyclerView.Adapter<MenuAdapter.ViewHolder>() {
    private val model = menuModelFactory.createMenuModel()
    class ViewHolder(val view: MenuCellView) : RecyclerView.ViewHolder
(view)
    override fun onCreateViewHolder(parent: ViewGroup, viewType: Int):
 ViewHolder {
        val view = LayoutInflater.from(parent.context)
            .inflate(R.layout.menu_cell, parent, false) as MenuCellVie
w
        return ViewHolder(view)
    }
    override fun getItemCount() = model.size
    override fun onBindViewHolder(holder: ViewHolder, position: Int) {
        val model = model.get(position)
        val view = holder.view
        view.setTitle(model.title)
        when (model.type) {
            CellType.BUTTON -> view.setOnClickCallback { model.onClick
Callback() }
            CellType.SWITCHER -> view.apply {
                setSwitcherEnabled(model.switcherEnabled)
                view.setOnSwitcherChecked { model.onSwitcherChecked(it
) }
            }
        }
    }
}
\end{verbatim}

\subsection{MenuModelFactory.kt}
\begin{verbatim}
package com.closecom.app.ui.common.menu
interface MenuModelFactory {
    fun createMenuModel(): MenuModel
}
\end{verbatim}

\subsection{MenuModel.kt}
\begin{verbatim}
package com.closecom.app.ui.common.menu
import androidx.annotation.StringRes
import com.closecom.app.domain.repo.ResourcesGateway
import javax.inject.Inject
class MenuModel private constructor(
    private val cells: List<MenuCell>
) {
    val size = cells.size
    fun get(index: Int) = cells[index]
    class Builder @Inject constructor(
        private val resourcesGateway: ResourcesGateway
    ) {
        private val cells = mutableListOf<MenuCell>()
        fun addButtonCell(
            @StringRes titleId: Int,
            onClickCallback: () -> Unit
        ): Builder {
            val cell = MenuCell(
                resourcesGateway.string(titleId),
                CellType.BUTTON
            ).apply {
                this.onClickCallback = onClickCallback
            }
            cells.add(cell)
            return this
        }
        fun addSwitcherCell(
            @StringRes titleId: Int,
            enabled: Boolean,
            onSwitcherChecked: (Boolean) -> Unit
        ): Builder {
            val cell = MenuCell(
                resourcesGateway.string(titleId),
                CellType.SWITCHER
            ).apply {
                this.onSwitcherChecked = onSwitcherChecked
                switcherEnabled = enabled
            }
            cells.add(cell)
            return this
        }
        fun build() = MenuModel(cells)
    }
}
\end{verbatim}

\subsection{MenuCell.kt}
\begin{verbatim}
package com.closecom.app.ui.common.menu
class MenuCell(
    var title: String,
    var type: CellType
) {
    var onClickCallback: () -> Unit = {}
    var onSwitcherChecked: (Boolean) -> Unit = { }
    var switcherEnabled = true
}
\end{verbatim}

\subsection{MenuCellView.kt}
\begin{verbatim}
package com.closecom.app.ui.common.menu
import android.content.Context
import android.util.AttributeSet
import android.view.View
import androidx.constraintlayout.widget.ConstraintLayout
import androidx.core.view.isVisible
import com.closecom.R
import kotlinx.android.synthetic.main.settings_cell_body.view.*
class MenuCellView(
    context: Context,
    attributeSet: AttributeSet
) : ConstraintLayout(context, attributeSet) {
    init {
        View.inflate(context, R.layout.settings_cell_body, this)
    }
    fun setTitle(title: String) {
        text_title.text = title
    }
    fun setOnClickCallback(onClickCallback: () -> Unit) {
        setOnClickListener { onClickCallback() }
    }
    fun setOnSwitcherChecked(onSwitchChanged: (Boolean) -> Unit) {
        switch_settings.apply {
            isVisible = true
            setOnCheckedChangeListener { _, isChecked ->
                onSwitchChanged(isChecked)
            }
        }
    }
    fun setSwitcherEnabled(enabled: Boolean) {
        switch_settings.isChecked = enabled
    }
}
\end{verbatim}

\subsection{CellType.kt}
\begin{verbatim}
package com.closecom.app.ui.common.menu
enum class CellType {
    BUTTON,
    SWITCHER
}
\end{verbatim}

\subsection{MenuAdaptersFactory.kt}
\begin{verbatim}
package com.closecom.app.ui.common.menu
import com.closecom.app.ui.develop.DevMenuModelFactory
import com.closecom.app.ui.settings.SettingsMenuModelFactory
import com.closecom.app.ui.slide_menu.SlideMenuModelFactory
import javax.inject.Inject
class MenuAdaptersFactory @Inject constructor(
    private val settingsMenuModelFactory: SettingsMenuModelFactory,
    private val slideMenuModelFactory: SlideMenuModelFactory,
    private val devMenuModelFactory: DevMenuModelFactory
) {
    fun createSlideMenuAdapter(): MenuAdapter {
        return MenuAdapter(slideMenuModelFactory)
    }
    fun createSettingsMenuAdapter(): MenuAdapter {
        return MenuAdapter(settingsMenuModelFactory)
    }
    fun createDevSettingsAdapter(): MenuAdapter {
        return MenuAdapter(devMenuModelFactory)
    }
}
\end{verbatim}

\subsection{BluetoothCellView.kt}
\begin{verbatim}
package com.closecom.app.ui.bluetooth
import android.content.Context
import android.util.AttributeSet
import android.view.View
import androidx.constraintlayout.widget.ConstraintLayout
import com.closecom.R
import com.closecom.app.domain.model.UserBluetooth
import kotlinx.android.synthetic.main.bluetooth_cell_body.view.*
class BluetoothCellView(
    context: Context,
    attributeSet: AttributeSet
) : ConstraintLayout(context, attributeSet) {
    init {
        View.inflate(context, R.layout.bluetooth_cell_body, this)
    }
    fun setBluetoothData(data: UserBluetooth) {
        text_title.text = if (data.user.email.isEmpty()) "Not defined"
 else data.user.email
        text_bid.text = data.bid
    }
}
\end{verbatim}

\subsection{BluetoothListAdapter.kt}
\begin{verbatim}
package com.closecom.app.ui.bluetooth
import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import androidx.recyclerview.widget.RecyclerView
import com.closecom.R
import com.closecom.app.domain.model.UserBluetooth
import com.closecom.app.domain.usecase.OpenNewDialogUseCase
import javax.inject.Inject
private const val LOADING = 0
private const val CELL = 1
class BluetoothListAdapter @Inject constructor(
    private val openNewDialogUseCase: OpenNewDialogUseCase
) :
    RecyclerView.Adapter<BluetoothListAdapter.ViewHolder>() {
    var data: List<UserBluetooth> = emptyList()
        set(value) {
            field = value
            notifyDataSetChanged()
        }
    override fun onCreateViewHolder(parent: ViewGroup, viewType: Int):
 ViewHolder {
        val res = when (viewType) {
            LOADING -> R.layout.bluetooth_cell_loading
            else -> R.layout.bluetooth_cell
        }
        val view =
            LayoutInflater.from(parent.context).inflate(res, parent, f
alse)
        return ViewHolder(view)
    }
    override fun getItemCount(): Int {
        return if (data.isEmpty()) 1 else data.size
    }
    override fun getItemViewType(position: Int): Int {
        return if (position == 0 && data.isEmpty()) {
            LOADING
        } else {
            CELL
        }
    }
    override fun onBindViewHolder(holder: ViewHolder, position: Int) {
        holder.view?.apply {
            val userBluetooth = data[position]
            setBluetoothData(userBluetooth)
            setOnClickListener {
                openNewDialogUseCase.execute(userBluetooth.user)
            }
        }
    }
    class ViewHolder(view: View) : RecyclerView.ViewHolder(view) {
        val view = view as? BluetoothCellView
    }
}
\end{verbatim}

\subsection{BluetoothFragment.kt}
\begin{verbatim}
package com.closecom.app.ui.bluetooth
import android.os.Bundle
import android.util.Log
import android.view.View
import androidx.recyclerview.widget.LinearLayoutManager
import com.closecom.R
import com.closecom.app.di.AppSdk
import com.closecom.app.domain.model.ScreenType
import com.closecom.app.domain.repo.BluetoothGateway
import com.closecom.app.domain.repo.PermissionGateway
import com.closecom.app.ui.common.fragments.BaseFragment
import io.reactivex.rxjava3.android.schedulers.AndroidSchedulers
import io.reactivex.rxjava3.disposables.CompositeDisposable
import javax.inject.Inject
import kotlinx.android.synthetic.main.bluetooth_fragment_layout.*
class BluetoothFragment : BaseFragment(R.layout.bluetooth_fragment_lay
out) {
    override val screenType = ScreenType.BLUETOOTH
    private val compositeDisposable = CompositeDisposable()
    @Inject
    lateinit var permissionGateway: PermissionGateway
    @Inject
    lateinit var bluetoothGateway: BluetoothGateway
    @Inject
    lateinit var bluetoothAdapter: BluetoothListAdapter
    override fun onViewCreated(view: View, savedInstanceState: Bundle?
) {
        super.onViewCreated(view, savedInstanceState)
        AppSdk.appComponent.inject(this)
        setActionBar()
        recycler_bluetooth_search.apply {
            adapter = bluetoothAdapter
            layoutManager = LinearLayoutManager(context)
        }
        compositeDisposable.add(
            bluetoothGateway.usersBluetooth()
                .subscribeOn(AndroidSchedulers.mainThread())
                .observeOn(AndroidSchedulers.mainThread())
                .subscribe { bluetoothAdapter.data = it }
        )
        if (!permissionGateway.hasPermissions(permissionGateway.blueto
othPermissions())) {
            permissionGateway.requestPermission(permissionGateway.blue
toothPermissions())
        } else {
            bluetoothGateway.startScan()
        }
    }
    override fun onDetach() {
        Log.d("kek", "detach")
        bluetoothGateway.stopScan()
        super.onDetach()
    }
    private fun setActionBar() {
        actionBar().setTitle(R.string.action_bar_bluetooth_search)
    }
}
\end{verbatim}

\subsection{AppModule.kt}
\begin{verbatim}
package com.closecom.app.di
import android.content.Context
import com.closecom.app.api.data.repo.ClosecomAPIImpl
import com.closecom.app.api.data.repo.mvp.MvpApiImpl
import com.closecom.app.api.data.repo.requests.RequestsBuilderFactoryI
mpl
import com.closecom.app.api.domain.repo.ClosecomAPI
import com.closecom.app.api.domain.repo.requests.RequestsBuilderFactor
y
import com.closecom.app.data.repo.BluetoothRepo
import com.closecom.app.data.repo.ExecutorRepo
import com.closecom.app.data.repo.MainHandlerImpl
import com.closecom.app.data.repo.NavigationRepo
import com.closecom.app.data.repo.NightModeManagerImpl
import com.closecom.app.data.repo.PermissionRepo
import com.closecom.app.data.repo.PreferencesRepo
import com.closecom.app.data.repo.RequestsExecutorImpl
import com.closecom.app.data.repo.ResourcesRepo
import com.closecom.app.data.repo.SearchUserRepo
import com.closecom.app.data.repo.SettingsRepo
import com.closecom.app.data.repo.auth.AuthRepo
import com.closecom.app.data.repo.mappers.ScreenMapperImpl
import com.closecom.app.data.repo.mappers.ShowActionBarMapperImpl
import com.closecom.app.data.repo.messanger.ChatsRepo
import com.closecom.app.domain.repo.BluetoothGateway
import com.closecom.app.domain.repo.ExecutorGateway
import com.closecom.app.domain.repo.MainHandler
import com.closecom.app.domain.repo.NavigationGateway
import com.closecom.app.domain.repo.NightModeManager
import com.closecom.app.domain.repo.PermissionGateway
import com.closecom.app.domain.repo.PreferencesGateway
import com.closecom.app.domain.repo.RequestsExecutor
import com.closecom.app.domain.repo.ResourcesGateway
import com.closecom.app.domain.repo.SearchUsersGateway
import com.closecom.app.domain.repo.SettingsGateway
import com.closecom.app.domain.repo.auth.AuthGateway
import com.closecom.app.domain.repo.auth.TokenGateway
import com.closecom.app.domain.repo.mappers.ScreenMapper
import com.closecom.app.domain.repo.mappers.ShowActionBarMapper
import com.closecom.app.domain.repo.messanger.ActiveChatGateway
import com.closecom.app.domain.repo.messanger.ChatsGateway
import com.closecom.develop.domain.repo.DevSettingsGateway
import dagger.Module
import dagger.Provides
import java.util.Locale
import javax.inject.Singleton
@Module
class AppModule(private val context: Context) {
    @Provides
    fun applicationContext(): Context = context.applicationContext
    @Provides
    @Singleton
    fun chatsGateway(chatsRepo: ChatsRepo): ChatsGateway = chatsRepo
    @Provides
    @Singleton
    fun navigationGateway(navigationRepo: NavigationRepo): NavigationG
ateway = navigationRepo
    @Provides
    fun screenMapper(screenMapperImpl: ScreenMapperImpl): ScreenMapper
 = screenMapperImpl
    @Provides
    @Singleton
    fun activeChatGateway(chatsRepo: ChatsRepo): ActiveChatGateway = c
hatsRepo
    @Provides
    @Singleton
    fun authGateway(authRepo: AuthRepo): AuthGateway = authRepo
    @Provides
    @Singleton
    fun tokenGateway(authRepo: AuthRepo): TokenGateway = authRepo
    @Provides
    @Singleton
    fun resourcesGateway(resourcesRepo: ResourcesRepo): ResourcesGatew
ay = resourcesRepo
    @Provides
    @Singleton
    fun preferencesGateway(preferencesRepo: PreferencesRepo): Preferen
cesGateway = preferencesRepo
    @Provides
    @Singleton
    fun executorGateway(executorRepo: ExecutorRepo): ExecutorGateway =
 executorRepo
    @Provides
    @Singleton
    fun mainHandler(mainHandlerImpl: MainHandlerImpl): MainHandler = m
ainHandlerImpl
    @Provides
    @Singleton
    fun requestsExecutor(requestsExecutorImpl: RequestsExecutorImpl): 
RequestsExecutor =
        requestsExecutorImpl
    @Provides
    @Singleton
    fun settingsGateway(settingsRepo: SettingsRepo): SettingsGateway =
 settingsRepo
    @Provides
    @Singleton
    fun nightModeManager(nightModeManagerImpl: NightModeManagerImpl): 
NightModeManager =
        nightModeManagerImpl
    @Provides
    @Singleton
    fun showToolbarMapper(showToolbarMapperImpl: ShowActionBarMapperIm
pl): ShowActionBarMapper =
        showToolbarMapperImpl
    @Provides
    @Singleton
    fun searchUserGateway(searchUserRepo: SearchUserRepo): SearchUsers
Gateway = searchUserRepo
    @Singleton
    @Provides
    fun closecomApi(
        devSettingsGateway: DevSettingsGateway,
        mvpApiImpl: MvpApiImpl,
        closecomAPIImpl: ClosecomAPIImpl
    ): ClosecomAPI = if (devSettingsGateway.mockApi) mvpApiImpl else c
losecomAPIImpl
    @Provides
    fun requestBuilderFactory(requestBuilderFactoryImpl: RequestsBuild
erFactoryImpl): RequestsBuilderFactory =
        requestBuilderFactoryImpl
    @Provides
    fun locale(): Locale = context.resources.configuration.locales[0]
    @Provides
    @Singleton
    fun permissionGateway(permissionRepo: PermissionRepo): PermissionG
ateway = permissionRepo
    @Provides
    @Singleton
    fun bluetoothGateway(bluetoothRepo: BluetoothRepo): BluetoothGatew
ay = bluetoothRepo
}
\end{verbatim}

\subsection{AppSdk.kt}
\begin{verbatim}
package com.closecom.app.di
import android.content.Context
import com.closecom.app.domain.repo.NightModeManager
import com.closecom.develop.di.DevComponent
object AppSdk {
    private lateinit var applicationContext: Context
    private lateinit var devComponent: DevComponent
    private lateinit var nightModeManager: NightModeManager
    val appComponent: AppComponent by lazy {
        DaggerAppComponent.builder()
            .devComponent(devComponent)
            .appModule(AppModule(applicationContext))
            .build()
    }
    @JvmStatic
    fun init(context: Context, devComponent: DevComponent) {
        applicationContext = context.applicationContext
        this.devComponent = devComponent
        nightModeManager = appComponent.nightModeManager()
    }
}
\end{verbatim}

\subsection{AppComponent.kt}
\begin{verbatim}
package com.closecom.app.di
import com.closecom.app.domain.repo.NightModeManager
import com.closecom.app.ui.MainActivity
import com.closecom.app.ui.MainFragment
import com.closecom.app.ui.auth.AuthFragment
import com.closecom.app.ui.bluetooth.BluetoothFragment
import com.closecom.app.ui.chat.ChatFragment
import com.closecom.app.ui.chat.message_list.MessageListViewImpl
import com.closecom.app.ui.chat.message_list.message_cell.MessageCellV
iewImpl
import com.closecom.app.ui.chat.message_list.message_view.MessageViewI
mpl
import com.closecom.app.ui.chat_list.ChatListViewImpl
import com.closecom.app.ui.chat_list.chat_cell.ChatCellPresenter
import com.closecom.app.ui.chat_list.chat_cell.ChatCellViewImpl
import com.closecom.app.ui.common.fragments.BaseFragment
import com.closecom.app.ui.develop.DevelopFragment
import com.closecom.app.ui.search.SearchViewImpl
import com.closecom.app.ui.settings.SettingsFragment
import com.closecom.app.ui.slide_menu.SlideMenuViewImpl
import com.closecom.develop.di.DevComponent
import dagger.Component
import javax.inject.Singleton
@Singleton
@Component(
    dependencies = [
        DevComponent::class
    ],
    modules = [
        AppModule::class
    ]
)
interface AppComponent {
    fun inject(chatListViewImpl: ChatListViewImpl)
    fun inject(chatCellViewImpl: ChatCellViewImpl)
    fun inject(chatCellPresenter: ChatCellPresenter)
    fun inject(mainActivity: MainActivity)
    fun inject(chatFragment: ChatFragment)
    fun inject(messageViewImpl: MessageViewImpl)
    fun inject(messagesCellImpl: MessageCellViewImpl)
    fun inject(messageListViewImpl: MessageListViewImpl)
    fun inject(authFragment: AuthFragment)
    fun inject(mainFragment: MainFragment)
    fun inject(settingsFragment: SettingsFragment)
    fun inject(slideMenuViewImpl: SlideMenuViewImpl)
    fun inject(baseFragment: BaseFragment)
    fun inject(developFragment: DevelopFragment)
    fun inject(bluetoothFragment: BluetoothFragment)
    fun inject(searchView: SearchViewImpl)
    fun nightModeManager(): NightModeManager
}
\end{verbatim}

\subsection{NavigationRepo.kt}
\begin{verbatim}
package com.closecom.app.data.repo
import com.closecom.app.domain.model.ScreenType
import com.closecom.app.domain.repo.NavigationGateway
import io.reactivex.rxjava3.core.Flowable
import io.reactivex.rxjava3.processors.BehaviorProcessor
import java.util.Optional
import javax.inject.Inject
class NavigationRepo @Inject constructor() :
    NavigationGateway {
    private val backStack = BehaviorProcessor.createDefault(emptyList<
ScreenType>())
    override fun openScreen(screenType: ScreenType) {
        val stack = backStack.value!!.toMutableList()
        // Don't open screen again
        if (stack.isNotEmpty() && stack.last() == screenType) return
        stack.add(screenType)
        backStack.onNext(stack)
    }
    override fun openScreenWithReset(screenType: ScreenType) {
        val stack = listOf(screenType)
        backStack.onNext(stack)
    }
    @ExperimentalStdlibApi
    override fun switchScreenWith(screenType: ScreenType) {
        val stack = backStack.value!!.toMutableList()
        if (stack.isEmpty() || stack.last() == screenType) return
        stack.removeLast()
        stack.add(screenType)
        backStack.onNext(stack.toList())
    }
    @ExperimentalStdlibApi
    override fun navigateBack() {
        val stack = backStack.value.toMutableList()
        if (stack.isNotEmpty()) {
            stack.removeLast()
        }
        backStack.onNext(stack.toList())
    }
    override fun screen(): Flowable<Optional<ScreenType>> {
        return backStack.map { Optional.ofNullable(it.lastOrNull()) }.
distinctUntilChanged()!!
    }
    override fun screenSync(): Optional<ScreenType> {
        return Optional.ofNullable(backStack.value.lastOrNull())
    }
}
\end{verbatim}

\subsection{RequestsExecutorImpl.kt}
\begin{verbatim}
package com.closecom.app.data.repo
import com.closecom.app.api.domain.model.Response
import com.closecom.app.domain.repo.ExecutorGateway
import com.closecom.app.domain.repo.MainHandler
import com.closecom.app.domain.repo.RequestsExecutor
import javax.inject.Inject
class RequestsExecutorImpl @Inject constructor(
    private val executorGateway: ExecutorGateway,
    private val mainHandler: MainHandler
) : RequestsExecutor {
    override fun <R> execute(task: () -> Response<R>, onResult: (Respo
nse<R>) -> Unit) {
        executorGateway.execute {
            val response = task.invoke()
            mainHandler.runOnUi { onResult.invoke(response) }
        }
    }
}
\end{verbatim}

\subsection{PermissionRepo.kt}
\begin{verbatim}
package com.closecom.app.data.repo
import android.Manifest
import android.content.Context
import android.content.pm.PackageManager
import androidx.core.content.ContextCompat
import com.closecom.app.domain.repo.NavigationGateway
import com.closecom.app.domain.repo.PermissionGateway
import io.reactivex.rxjava3.processors.PublishProcessor
import javax.inject.Inject
class PermissionRepo @Inject constructor(
    private val context: Context,
    private val navigationGateway: NavigationGateway
) : PermissionGateway {
    private val permissionsPublisher = PublishProcessor.create<List<St
ring>>()
    override fun requestPermission(names: List<String>) {
        permissionsPublisher.onNext(names)
    }
    override fun hasPermissions(names: List<String>): Boolean = names.
all { granted(it) }
    override fun permission() = permissionsPublisher!!
    override fun bluetoothPermissions(): List<String> {
        return listOf(
            Manifest.permission.BLUETOOTH,
            Manifest.permission.BLUETOOTH_ADMIN,
            Manifest.permission.ACCESS_COARSE_LOCATION,
            Manifest.permission.INTERNET,
            Manifest.permission.ACCESS_FINE_LOCATION,
            Manifest.permission.ACCESS_NETWORK_STATE
        )
    }
    override fun onResult(isSuccess: Boolean) {
        if (!isSuccess) {
            navigationGateway.navigateBack()
        }
    }
    private fun granted(permission: String): Boolean =
        ContextCompat.checkSelfPermission(context, permission) == Pack
ageManager.PERMISSION_GRANTED
}
\end{verbatim}

\subsection{NightModeManagerImpl.kt}
\begin{verbatim}
package com.closecom.app.data.repo
import android.app.UiModeManager
import android.content.Context
import com.closecom.app.domain.repo.NightModeManager
import com.closecom.app.domain.repo.SettingsGateway
import io.reactivex.rxjava3.android.schedulers.AndroidSchedulers
import io.reactivex.rxjava3.disposables.Disposable
import javax.inject.Inject
import javax.inject.Singleton
@Singleton
class NightModeManagerImpl @Inject constructor(
    settingsGateway: SettingsGateway,
    context: Context
) : NightModeManager {
    private val uiManager = context.getSystemService(Context.UI_MODE_S
ERVICE) as UiModeManager
    private val disposable: Disposable
    init {
        disposable = settingsGateway
            .nightModeFlowable()
            .subscribeOn(AndroidSchedulers.mainThread())
            .observeOn(AndroidSchedulers.mainThread())
            .subscribe {
                applyTheme(it)
            }
    }
    private fun applyTheme(isNight: Boolean) {
        uiManager.nightMode = if (isNight) {
            UiModeManager.MODE_NIGHT_YES
        } else {
            UiModeManager.MODE_NIGHT_NO
        }
    }
}
\end{verbatim}

\subsection{ExecutorRepo.kt}
\begin{verbatim}
package com.closecom.app.data.repo
import com.closecom.app.domain.repo.ExecutorGateway
import java.util.concurrent.ExecutorService
import java.util.concurrent.Executors
import java.util.concurrent.Future
import javax.inject.Inject
import javax.inject.Singleton
private const val THREAD_POOL_NUMBER = 4
@Singleton
class ExecutorRepo @Inject constructor() : ExecutorGateway {
    private val executor: ExecutorService by lazy {
        Executors.newFixedThreadPool(THREAD_POOL_NUMBER)
    }
    override fun execute(runnable: () -> Unit) {
        executor.execute(runnable)
    }
    override fun submit(runnable: () -> Unit): Future<*> {
        return executor.submit(runnable)
    }
}
\end{verbatim}

\subsection{MainHandlerImpl.kt}
\begin{verbatim}
package com.closecom.app.data.repo
import android.os.Looper
import androidx.core.os.HandlerCompat
import com.closecom.app.domain.repo.MainHandler
import javax.inject.Inject
import javax.inject.Singleton
@Singleton
class MainHandlerImpl @Inject constructor() : MainHandler {
    private val handler = HandlerCompat.createAsync(Looper.getMainLoop
er())
    override fun runOnUi(runnable: () -> Unit) {
        handler.post { runnable() }
    }
}
\end{verbatim}

\subsection{BluetoothRepo.kt}
\begin{verbatim}
package com.closecom.app.data.repo
import android.bluetooth.BluetoothAdapter
import android.bluetooth.le.BluetoothLeScanner
import android.bluetooth.le.ScanCallback
import android.bluetooth.le.ScanResult
import android.content.Context
import android.provider.Settings
import android.util.Log
import com.closecom.app.domain.model.UserBluetooth
import com.closecom.app.domain.repo.BluetoothGateway
import com.closecom.app.domain.repo.PermissionGateway
import com.closecom.app.domain.usecase.requests.FetchBluetoothUser
import com.closecom.app.domain.usecase.requests.SetBidUseCase
import com.closecom.develop.di.DevModule_ContextFactory.context
import io.reactivex.rxjava3.core.Flowable
import io.reactivex.rxjava3.processors.BehaviorProcessor
import javax.inject.Inject
private const val TAG = "BluetoothRepo"
class BluetoothRepo @Inject constructor(
    private val fetchBluetoothUser: FetchBluetoothUser,
    private val setBidUseCase: SetBidUseCase,
    private val permissionGateway: PermissionGateway,
    private val context: Context
) : BluetoothGateway {
    private val devicesProcessor = BehaviorProcessor.createDefault(emp
tyList<UserBluetooth>())
    private val devices = mutableListOf<String>()
    private val bluetoothAdapter: BluetoothAdapter by lazy { Bluetooth
Adapter.getDefaultAdapter() }
    private val scanner: BluetoothLeScanner by lazy { bluetoothAdapter
.bluetoothLeScanner }
    private val macAddress = Settings.Secure.getString(
        context.contentResolver,
        "bluetooth_address"
    ) ?: "some_mac"
    override fun isBluetoothEnabled(): Boolean {
        return bluetoothAdapter.isEnabled
    }
    override fun usersBluetooth(): Flowable<List<UserBluetooth>> {
        return devicesProcessor.distinctUntilChanged()
    }
    override fun startScan() {
        Log.d(TAG, "bluetooth_start_scan")
        scanner.startScan(object : ScanCallback() {
            override fun onScanResult(callbackType: Int, result: ScanR
esult) {
                Log.d(TAG, "onScanResult")
                val mac = result.device.address
                if (devices.find { it == mac } == null) {
                    devices.add(mac)
                    addDevicesToList(mac)
                }
            }
            override fun onScanFailed(errorCode: Int) {
                super.onScanFailed(errorCode)
                Log.d(TAG, "onScanFailed errorCode: $errorCode")
            }
            override fun onBatchScanResults(results: MutableList<ScanR
esult>?) {
                super.onBatchScanResults(results)
                Log.d(TAG, "onBatchScanResults")
            }
        })
    }
    override fun stopScan() {
        Log.d(TAG, "stop_scan")
        scanner.stopScan(object : ScanCallback() {})
    }
    override fun trySetBid() {
        Log.d(TAG, "set_bid bid: $macAddress")
        if (permissionGateway.hasPermissions(permissionGateway.bluetoo
thPermissions())) {
            setBidUseCase.execute(
                { Log.d(TAG, "set_bid_success") },
                { code, message -> Log.d(TAG, "set_bid_error code: $co
de, message: $message") }, macAddress)
        }
    }
    private fun addDevicesToList(mac: String) {
        Log.d(TAG, "add_bluetooth_device")
        fetchBluetoothUser.execute({
            Log.d(TAG, "add_bluetooth_device_success user: $it, bid: $
mac")
            val devices = devicesProcessor.value.toMutableList()
            devices.add(UserBluetooth(mac, it))
            devicesProcessor.onNext(devices)
        }, { _, _ ->
            Log.d(TAG, "add_bluetooth_device_error")
        }, mac)
    }
}
\end{verbatim}

\subsection{SettingsRepo.kt}
\begin{verbatim}
package com.closecom.app.data.repo
import com.closecom.app.domain.repo.PreferencesGateway
import com.closecom.app.domain.repo.SettingsGateway
import io.reactivex.rxjava3.processors.BehaviorProcessor
import javax.inject.Inject
private const val KEY_SETTINGS = "key_settings"
private const val NIGHT_MODE = "${KEY_SETTINGS}_night_mode"
private const val NIGHT_MODE_DEFAULT = true
class SettingsRepo @Inject constructor(
    private val preferencesGateway: PreferencesGateway
) : SettingsGateway {
    private val nightModeFlowable = BehaviorProcessor.createDefault(ni
ghtMode)
    override var nightMode: Boolean
        get() = preferencesGateway.getBoolean(NIGHT_MODE, NIGHT_MODE_D
EFAULT)
        set(value) {
            preferencesGateway.putBoolean(NIGHT_MODE, value)
            nightModeFlowable.onNext(value)
        }
    override fun nightModeFlowable() = nightModeFlowable.distinctUntil
Changed()!!
}
\end{verbatim}

\subsection{ResourcesRepo.kt}
\begin{verbatim}
package com.closecom.app.data.repo
import android.content.Context
import com.closecom.app.domain.repo.ResourcesGateway
import javax.inject.Inject
class ResourcesRepo @Inject constructor(
    private val context: Context
) : ResourcesGateway {
    override fun string(id: Int) = context.resources.getString(id)
}
\end{verbatim}

\subsection{PreferencesRepo.kt}
\begin{verbatim}
package com.closecom.app.data.repo
import android.content.Context
import com.closecom.app.domain.repo.PreferencesGateway
import javax.inject.Inject
private const val KEY_CLOSECOM_PREFERENCES = "key_closecome_preference
s"
class PreferencesRepo @Inject constructor(
    context: Context
) : PreferencesGateway {
    private val prefs =
        context.getSharedPreferences(KEY_CLOSECOM_PREFERENCES, Context
.MODE_PRIVATE)
    override fun getString(key: String, default: String?): String? {
        return prefs.getString(key, default)
    }
    override fun putString(key: String, value: String?) {
        prefs.edit()
            .putString(key, value)
            .apply()
    }
    override fun getBoolean(key: String, default: Boolean): Boolean {
        return prefs.getBoolean(key, default)
    }
    override fun putBoolean(key: String, value: Boolean) {
        prefs.edit()
            .putBoolean(key, value)
            .apply()
    }
}
\end{verbatim}

\subsection{SearchUserRepo.kt}
\begin{verbatim}
package com.closecom.app.data.repo
import android.util.Log
import com.closecom.app.api.domain.model.User
import com.closecom.app.domain.repo.ExecutorGateway
import com.closecom.app.domain.repo.MainHandler
import com.closecom.app.domain.repo.SearchUsersGateway
import com.closecom.app.domain.usecase.requests.FetchUserSearchUseCase
import io.reactivex.rxjava3.core.Flowable
import io.reactivex.rxjava3.processors.BehaviorProcessor
import io.reactivex.rxjava3.processors.PublishProcessor
import java.util.concurrent.CompletableFuture
import java.util.concurrent.Future
import javax.inject.Inject
private const val TAG = "SearchUserRepo"
private const val TIMEOUT = 500L
class SearchUserRepo @Inject constructor(
    private val fetchUserSearchUseCase: FetchUserSearchUseCase,
    private val executorGateway: ExecutorGateway,
    private val mainHandler: MainHandler
) : SearchUsersGateway {
    private val searchResultPublisher = PublishProcessor.create<List<U
ser>>()
    private val loadingPublisher = BehaviorProcessor.createDefault(fal
se)
    private var searchHandle: Future<*> = CompletableFuture.completedF
uture(Any())
    override fun searchResult(): Flowable<List<User>> = searchResultPu
blisher.distinctUntilChanged()
    override fun loading(): Flowable<Boolean> = loadingPublisher.disti
nctUntilChanged()
    override fun requestSearch(pattern: String) {
        loadingPublisher.onNext(true)
        if (!searchHandle.isDone) {
            searchHandle.cancel(true)
        }
        searchHandle = executorGateway.submit {
            if (pattern.isNotEmpty()) {
                Thread.sleep(TIMEOUT)
            }
            mainHandler.runOnUi {
                requestSearchImpl(pattern)
            }
        }
    }
    private fun requestSearchImpl(pattern: String) {
        if (pattern.isEmpty()) {
            searchResultPublisher.onNext(emptyList())
            loadingPublisher.onNext(false)
            return
        }
        fetchUserSearchUseCase.execute(pattern, {
            Log.d(TAG, "user_search_success")
            searchResultPublisher.onNext(it)
            loadingPublisher.onNext(false)
        }) { code, message ->
            Log.e(TAG, "user_search_error code: $code, message: $messa
ge")
            loadingPublisher.onNext(false)
        }
    }
}
\end{verbatim}

\subsection{AuthRepo.kt}
\begin{verbatim}
package com.closecom.app.data.repo.auth
import android.content.Context
import android.util.Log
import android.widget.Toast
import com.closecom.app.domain.model.AuthInfo
import com.closecom.app.domain.repo.PreferencesGateway
import com.closecom.app.domain.repo.auth.AuthGateway
import com.closecom.app.domain.repo.auth.TokenGateway
import com.closecom.app.domain.usecase.requests.auth.AccountDeleteUseC
ase
import com.closecom.app.domain.usecase.requests.auth.AuthAccountUseCas
e
import com.closecom.app.domain.usecase.requests.auth.CreateAccountUseC
ase
import com.closecom.app.domain.usecase.requests.auth.PasswordRecoveryU
seCase
import io.reactivex.rxjava3.core.Flowable
import io.reactivex.rxjava3.processors.BehaviorProcessor
import java.util.Optional
import javax.inject.Inject
private const val KEY_AUTH_INFO_EMAIL = "key_auth_info_email"
private const val KEY_AUTH_INFO_PASSWORD = "key_auth_info_password"
private const val KEY_AUTH_TOKEN = "key_auth_token"
private const val TAG = "AuthRepo"
class AuthRepo @Inject constructor(
    preferencesGateway: PreferencesGateway,
    private val context: Context,
    private val createAccountUseCase: CreateAccountUseCase,
    private val authAccountUseCase: AuthAccountUseCase,
    private val passwordRecoveryUseCase: PasswordRecoveryUseCase,
    private val accountDeleteUseCase: AccountDeleteUseCase
) : AuthGateway,
    TokenGateway {
    private val dataHolder = Storage(preferencesGateway)
    override fun authorized(): Flowable<Boolean> =
        dataHolder.token().map { it.isPresent }.distinctUntilChanged()
    override fun authorizedSync() = dataHolder.token.isPresent
    override fun reset() {
        dataHolder.reset()
    }
    override fun email() = dataHolder.authInfo.email
    override fun emailFlowable(): Flowable<String> =
        dataHolder.authInfo().map { it.email }.distinctUntilChanged()
    override fun deleteAccount() {
        Log.d(TAG, "account_delete")
        accountDeleteUseCase.execute({
            Log.d(TAG, "account_delete_success")
            dataHolder.reset()
        }, { code, message ->
            Log.d(TAG, "account_delete_error code: $code, message: $me
ssage")
            Toast.makeText(
                context,
                "Delete account error: $message",
                Toast.LENGTH_LONG
            ).show()
        }, dataHolder.token.get())
    }
    override fun passwordRecovery(email: String) {
        Log.d(TAG, "password_recovery")
        passwordRecoveryUseCase.execute({
            Log.d(TAG, "password_recovery_success")
            Toast.makeText(context, "Check your email for instructions
", Toast.LENGTH_LONG).show()
        }, { code, message ->
            Log.d(TAG, "password_recovery_error code: $code, message: 
$message")
            Toast.makeText(
                context,
                "Password recovery error: $message",
                Toast.LENGTH_LONG
            ).show()
        }, email)
    }
    override fun createAccount(authInfo: AuthInfo) {
        Log.d(TAG, "create_account")
        createAccountUseCase.execute({
            Log.d(TAG, "create_account_success")
            dataHolder.authInfo = authInfo
            dataHolder.token = Optional.of(it.toString())
        }, { code, message ->
            Log.d(TAG, "create_account_error code: $code, message: $me
ssage")
            Toast.makeText(
                context,
                "Create account error: $message",
                Toast.LENGTH_LONG
            ).show()
        }, authInfo.email, authInfo.password)
    }
    override fun auth(authInfo: AuthInfo) {
        Log.d(TAG, "auth_account")
        authAccountUseCase.execute({
            Log.d(TAG, "auth_account_success")
            dataHolder.authInfo = authInfo
            dataHolder.token = Optional.of(it.toString())
        }, { code, message ->
            Log.d(TAG, "auth_account_error code: $code, message: $mess
age")
            Toast.makeText(
                context,
                "Auth error: $message",
                Toast.LENGTH_LONG
            ).show()
        }, authInfo.email, authInfo.password)
    }
    override fun token(): Optional<String> {
        return dataHolder.token
    }
}
private class Storage(private val prefs: PreferencesGateway) {
    private val tokenProcessor = BehaviorProcessor.createDefault(token
)
    private val authInfoProcessor = BehaviorProcessor.createDefault(au
thInfo)
    var token: Optional<String>
        get() = Optional.ofNullable(prefs.getString(KEY_AUTH_TOKEN, nu
ll))
        set(value) {
            prefs.putString(KEY_AUTH_TOKEN, value.orElse(null))
            tokenProcessor.onNext(token)
        }
    var authInfo: AuthInfo
        get() {
            val email = prefs.getString(KEY_AUTH_INFO_EMAIL, "") ?: ""
            val password = prefs.getString(KEY_AUTH_INFO_PASSWORD, "")
 ?: ""
            return AuthInfo(email, password)
        }
        set(value) {
            prefs.putString(KEY_AUTH_INFO_EMAIL, value.email)
            prefs.putString(KEY_AUTH_INFO_PASSWORD, value.password)
            authInfoProcessor.onNext(authInfo)
        }
    fun reset() {
        token = Optional.empty()
        authInfo = AuthInfo("", "")
    }
    fun token(): Flowable<Optional<String>> = tokenProcessor.distinctU
ntilChanged()
    fun authInfo(): Flowable<AuthInfo> = authInfoProcessor.distinctUnt
ilChanged()
}
\end{verbatim}

\subsection{ChatsRepo.kt}
\begin{verbatim}
package com.closecom.app.data.repo.messanger
import android.util.Log
import com.closecom.app.api.domain.model.Chat
import com.closecom.app.api.domain.model.Message
import com.closecom.app.api.domain.model.User
import com.closecom.app.domain.model.ActiveChat
import com.closecom.app.domain.model.ScreenType
import com.closecom.app.domain.repo.MainHandler
import com.closecom.app.domain.repo.NavigationGateway
import com.closecom.app.domain.repo.auth.AuthGateway
import com.closecom.app.domain.repo.messanger.ActiveChatGateway
import com.closecom.app.domain.repo.messanger.ChatsGateway
import com.closecom.app.domain.usecase.requests.FetchChatsUseCase
import com.closecom.app.domain.usecase.requests.FetchMessagesUseCase
import com.closecom.app.domain.usecase.requests.FetchSendMessageUseCas
e
import com.closecom.app.domain.usecase.requests.StartDialogUseCase
import io.reactivex.rxjava3.android.schedulers.AndroidSchedulers
import io.reactivex.rxjava3.core.Completable
import io.reactivex.rxjava3.core.Flowable
import io.reactivex.rxjava3.disposables.CompositeDisposable
import io.reactivex.rxjava3.processors.BehaviorProcessor
import io.reactivex.rxjava3.processors.PublishProcessor
import io.reactivex.rxjava3.schedulers.Schedulers
import java.util.Optional
import java.util.concurrent.TimeUnit
import javax.inject.Inject
private const val TAG = "ChatsRepo"
private const val UPDATE_CHATS_TIMEOUT = 3L
private const val UPDATE_MESSAGES_TIMEOUT = 3L
class ChatsRepo @Inject constructor(
    private val fetchChatsUseCase: FetchChatsUseCase,
    private val fetchMessagesUseCase: FetchMessagesUseCase,
    private val fetchSendMessageUseCase: FetchSendMessageUseCase,
    private val startDialogUseCase: StartDialogUseCase,
    private val navigationGateway: NavigationGateway,
    private val mainHandler: MainHandler,
    authGateway: AuthGateway
) : ChatsGateway, ActiveChatGateway {
    private val chatsProcessor = BehaviorProcessor.createDefault<List<
Chat>>(emptyList())
    private val activeChatProcessor = BehaviorProcessor.createDefault(
Optional.empty<ActiveChat>())
    private val messagesPublisher = PublishProcessor.create<List<Messa
ge>>()
    private val compositeDisposable = CompositeDisposable()
    init {
        compositeDisposable.add(
            authGateway.authorized()
                .subscribeOn(AndroidSchedulers.mainThread())
                .observeOn(AndroidSchedulers.mainThread())
                .filter { !it }
                .subscribe { reset() }
        )
        compositeDisposable.add(
            pollingChats()
                .subscribeOn(AndroidSchedulers.mainThread())
                .observeOn(AndroidSchedulers.mainThread())
                .subscribe()
        )
        compositeDisposable.add(
            messagePolling()
                .subscribeOn(AndroidSchedulers.mainThread())
                .observeOn(AndroidSchedulers.mainThread())
                .subscribe()
        )
    }
    override fun chats() = chatsProcessor.distinctUntilChanged()!!
    override fun activeChat() = activeChatProcessor.distinctUntilChang
ed()!!
    override fun activeChatSync(): ActiveChat = activeChatProcessor.va
lue.get()
    override fun requestChat(chat: Chat) {
        Log.d(TAG, "request_chat")
        activeChatProcessor.onNext(Optional.of(ActiveChat(chat.id, cha
t.name)))
    }
    override fun requestFakeChat(user: User) {
        activeChatProcessor.onNext(
            Optional.of(ActiveChat(-1, user.email, true, user.id))
        )
    }
    override fun isFakeChat(): Flowable<Boolean> {
        return activeChatProcessor
            .filter { it.isPresent }
            .map { it.get().isFake }
            .distinctUntilChanged()
    }
    override fun messages() = messagesPublisher.distinctUntilChanged()
!!
    override fun updateMessages() {
        mainHandler.runOnUi {
            Log.d(TAG, "update_messages")
        }
        val activeChat = activeChatProcessor.value
        if (activeChat.get().isFake) {
            mainHandler.runOnUi {
                Log.d(TAG, "update_messages_fake")
                messagesPublisher.onNext(emptyList())
            }
            return
        }
        fetchMessagesUseCase.execute(activeChat.get().id, {
            Log.d(TAG, "update_messages_success")
            messagesPublisher.onNext(it)
        }, { code, message ->
            Log.d(TAG, "update_messages_error code: $code, message: $m
essage")
        })
    }
    override fun sendMessage(text: String) {
        Log.d(TAG, "send_message")
        if (activeChatSync().isFake) {
            startDialogUseCase.execute({
                Log.d(TAG, "start_dialog_success")
                activeChatProcessor.onNext(
                    Optional.of(ActiveChat(it, activeChatSync().name))
                )
                updateMessages()
            }, { code, message ->
                Log.d(TAG, "start_dialog_error code: $code, message: $
message")
            }, activeChatSync().userId, text)
            return
        }
        fetchSendMessageUseCase.execute(
            activeChatSync().id,
            text,
            {
                Log.d(TAG, "send_message_success")
                updateMessages()
            },
            { code, message ->
                Log.d(TAG, "send_message_error code: $code, message: $
message")
            }
        )
    }
    override fun updateChats(onUpdated: () -> Unit) {
        Log.d(TAG, "update_chats")
        fetchChatsUseCase.execute({
            Log.d(TAG, "update_chats_success")
            chatsProcessor.onNext(it)
            onUpdated()
        }, { code, message ->
            Log.d(TAG, "update_chats_error code:$code, message:$messag
e")
            onUpdated()
        })
    }
    override fun dialogWith(user: User): Optional<Chat> {
        val chat = chatsProcessor.value?.find { it.users.run { size ==
 2 && contains(user) } }
        return Optional.ofNullable(chat)
    }
    private fun reset() {
        chatsProcessor.onNext(emptyList())
        activeChatProcessor.onNext(Optional.empty())
    }
    private fun messagePolling(): Completable {
        return exceptionSafeCompletable {
            if (navigationGateway.screenSync().isPresent && navigation
Gateway.screenSync()
                    .get() == ScreenType.CHAT && activeChatProcessor.v
alue.isPresent && !activeChatProcessor.value.get().isFake
            ) {
                updateMessages()
            }
        }
            .repeatWhen { flowable ->
                flowable.switchMap {
                    Flowable.timer(
                        UPDATE_MESSAGES_TIMEOUT,
                        TimeUnit.SECONDS,
                        Schedulers.io()
                    )
                }
            }
    }
    private fun pollingChats(): Completable {
        return exceptionSafeCompletable {
            if (navigationGateway.screenSync().isPresent && navigation
Gateway.screenSync()
                    .get() == ScreenType.MAIN
            ) {
                updateChats()
            }
        }.repeatWhen { flowable ->
            flowable.switchMap {
                Flowable.timer(
                    UPDATE_CHATS_TIMEOUT,
                    TimeUnit.SECONDS,
                    Schedulers.io()
                )
            }
        }
    }
    private fun exceptionSafeCompletable(supplier: () -> Unit): Comple
table {
        return Completable.create { emitter ->
            try {
                supplier.invoke()
                emitter.onComplete()
            } catch (e: Exception) {
                emitter.tryOnError(e)
            }
        }
    }
}
\end{verbatim}

\subsection{ShowActionBarMapperImpl.kt}
\begin{verbatim}
package com.closecom.app.data.repo.mappers
import androidx.annotation.StringRes
import com.closecom.R
import com.closecom.app.domain.model.ActionBarModel
import com.closecom.app.domain.model.ButtonType
import com.closecom.app.domain.model.ScreenType
import com.closecom.app.domain.repo.mappers.ShowActionBarMapper
import javax.inject.Inject
class ShowActionBarMapperImpl @Inject constructor() : ShowActionBarMap
per {
    private val showForScreens = mapOf(
        ScreenType.MAIN to homeModel(),
        ScreenType.SETTINGS to backModel(R.string.action_bar_settings_
title),
        ScreenType.CHAT to backModel(R.string.action_bar_chat_title),
        ScreenType.BLUETOOTH to backModel(R.string.action_bar_bluetoot
h_search),
        ScreenType.SEARCH to backModel(R.string.action_bar_search)
    )
    override operator fun invoke(screenType: ScreenType): ActionBarMod
el {
        return showForScreens[screenType] ?: ActionBarModel()
    }
    private fun backModel(@StringRes id: Int): ActionBarModel {
        return ActionBarModel(
            ButtonType.BACK,
            id
        )
    }
    private fun homeModel(): ActionBarModel {
        return ActionBarModel(
            ButtonType.HOME,
            R.string.action_bar_chats_list_title
        )
    }
}
\end{verbatim}

\subsection{ScreenMapperImpl.kt}
\begin{verbatim}
package com.closecom.app.data.repo.mappers
import androidx.fragment.app.Fragment
import com.closecom.app.domain.model.ScreenType
import com.closecom.app.domain.repo.mappers.ScreenMapper
import com.closecom.app.ui.MainFragment
import com.closecom.app.ui.auth.AuthFragment
import com.closecom.app.ui.bluetooth.BluetoothFragment
import com.closecom.app.ui.chat.ChatFragment
import com.closecom.app.ui.develop.DevelopFragment
import com.closecom.app.ui.search.SearchFragment
import com.closecom.app.ui.settings.SettingsFragment
import javax.inject.Inject
class ScreenMapperImpl @Inject constructor() :
    ScreenMapper {
    override fun fragmentByScreenType(screenType: ScreenType): Fragmen
t {
        return when (screenType) {
            ScreenType.MAIN -> MainFragment()
            ScreenType.CHAT -> ChatFragment()
            ScreenType.AUTH -> AuthFragment()
            ScreenType.SETTINGS -> SettingsFragment()
            ScreenType.DEVELOP -> DevelopFragment()
            ScreenType.BLUETOOTH -> BluetoothFragment()
            ScreenType.SEARCH -> SearchFragment()
        }
    }
}
\end{verbatim}

\subsection{ChatCellData.kt}
\begin{verbatim}
package com.closecom.app.domain.model
class ChatCellData(
    val title: String,
    val description: String,
    val date: String
)
\end{verbatim}

\subsection{MessageCellData.kt}
\begin{verbatim}
package com.closecom.app.domain.model
class MessageCellData(
    val text: String,
    val date: String,
    val anchor: MessageAnchor
)
\end{verbatim}

\subsection{BluetoothData.kt}
\begin{verbatim}
package com.closecom.app.domain.model
class BluetoothData(
    val email: String,
    val bid: String
)
\end{verbatim}

\subsection{ActionBarModel.kt}
\begin{verbatim}
package com.closecom.app.domain.model
import com.closecom.R
data class ActionBarModel(
    var buttonType: ButtonType = ButtonType.EMPTY,
    var title: Int = R.string.empty_string
)
\end{verbatim}

\subsection{MessageAnchor.kt}
\begin{verbatim}
package com.closecom.app.domain.model
enum class MessageAnchor {
    LEFT,
    RIGHT
}
\end{verbatim}

\subsection{MessageType.kt}
\begin{verbatim}
package com.closecom.app.domain.model
enum class MessageType {
    TEXT,
    FILE,
    IMAGE
}
\end{verbatim}

\subsection{UserBluetooth.kt}
\begin{verbatim}
package com.closecom.app.domain.model
import com.closecom.app.api.domain.model.User
data class UserBluetooth(
    val bid: String,
    val user: User
)
\end{verbatim}

\subsection{ActiveChat.kt}
\begin{verbatim}
package com.closecom.app.domain.model
data class ActiveChat(
    val id: Long,
    val name: String,
    val isFake: Boolean = false,
    val userId: Long = 0
)
\end{verbatim}

\subsection{ButtonType.kt}
\begin{verbatim}
package com.closecom.app.domain.model
enum class ButtonType {
    HOME,
    BACK,
    EMPTY
}
\end{verbatim}

\subsection{ScreenType.kt}
\begin{verbatim}
package com.closecom.app.domain.model
enum class ScreenType {
    MAIN,
    CHAT,
    AUTH,
    SETTINGS,
    DEVELOP,
    BLUETOOTH,
    SEARCH
}
\end{verbatim}

\subsection{AuthInfo.kt}
\begin{verbatim}
package com.closecom.app.domain.model
data class AuthInfo(
    val email: String,
    val password: String
)
\end{verbatim}

\subsection{TimestampToDateMapper.kt}
\begin{verbatim}
package com.closecom.app.domain.usecase
import com.closecom.R
import com.closecom.app.domain.repo.ResourcesGateway
import java.text.SimpleDateFormat
import java.util.Date
import java.util.Locale
import javax.inject.Inject
class TimestampToDateMapper @Inject constructor(
    private val locale: Locale,
    private val resourcesGateway: ResourcesGateway
) {
    operator fun invoke(timestamp: Long): String {
        val nowTimestamp = System.currentTimeMillis()
        val dateNow = SimpleDateFormat("dd.MM", locale).run { format(D
ate(nowTimestamp)) }
        var date = SimpleDateFormat("dd.MM", locale).run { format(Date
(timestamp)) }
        if (dateNow == date) {
            date = resourcesGateway.string(R.string.date_mapper_today)
        }
        val time = SimpleDateFormat("HH:mm", locale).run { format(Date
(timestamp)) }
        return "$date, $time"
    }
}
\end{verbatim}

\subsection{NoAuthNavigationUseCase.kt}
\begin{verbatim}
package com.closecom.app.domain.usecase
import com.closecom.app.domain.model.ScreenType
import com.closecom.app.domain.repo.NavigationGateway
import com.closecom.app.domain.repo.auth.AuthGateway
import io.reactivex.rxjava3.core.Flowable
import javax.inject.Inject
class NoAuthNavigationUseCase @Inject constructor(
    private val authGateway: AuthGateway,
    private val navigationGateway: NavigationGateway
) {
    fun execute(): Flowable<Any> {
        return authGateway.authorized()
            .filter { !it }
            .filter { currentScreenNotAuth() }
            .map { Any() }
    }
    private val authScreens = listOf(
        ScreenType.AUTH
    )
    private fun currentScreenNotAuth(): Boolean {
        val optionalScreen = navigationGateway.screenSync()
        return !optionalScreen.isPresent || !authScreens.contains(opti
onalScreen.get())
    }
}
\end{verbatim}

\subsection{TimestampToTimeMapper.kt}
\begin{verbatim}
package com.closecom.app.domain.usecase
import java.text.SimpleDateFormat
import java.util.Date
import java.util.Locale
import javax.inject.Inject
class TimestampToTimeMapper @Inject constructor(
    private val locale: Locale
) {
    operator fun invoke(timestamp: Long): String {
        return SimpleDateFormat("HH:mm", locale).run {
            format(Date(timestamp))
        }
    }
}
\end{verbatim}

\subsection{MessageToMessageCellMapper.kt}
\begin{verbatim}
package com.closecom.app.domain.usecase
import com.closecom.app.api.domain.model.Message
import com.closecom.app.domain.model.MessageAnchor
import com.closecom.app.domain.model.MessageCellData
import com.closecom.app.domain.repo.auth.AuthGateway
import javax.inject.Inject
class MessageToMessageCellMapper @Inject constructor(
    private val timestampToTimeMapperUserCase: TimestampToTimeMapper,
    private val authGateway: AuthGateway
) {
    operator fun invoke(message: Message): MessageCellData {
        return message.run {
            MessageCellData(
                text!!,
                timestampToTimeMapperUserCase(timestamp),
                if (from == authGateway.email()) MessageAnchor.RIGHT e
lse MessageAnchor.LEFT
            )
        }
    }
}
\end{verbatim}

\subsection{ChatToCellDataMapper.kt}
\begin{verbatim}
package com.closecom.app.domain.usecase
import com.closecom.app.api.domain.model.Chat
import com.closecom.app.domain.model.ChatCellData
import javax.inject.Inject
class ChatToCellDataMapper @Inject constructor(
    private val timestampToDateMapper: TimestampToDateMapper,
    private val lastMessageToDescriptionMapper: LastMessageToDescripti
onMapper
) {
    operator fun invoke(chat: Chat): ChatCellData {
        return chat.run {
            ChatCellData(
                name,
                lastMessageToDescriptionMapper(lastMessage),
                timestampToDateMapper(lastMessage.timestamp)
            )
        }
    }
}
\end{verbatim}

\subsection{OpenNewDialogUseCase.kt}
\begin{verbatim}
package com.closecom.app.domain.usecase
import com.closecom.app.api.domain.model.User
import com.closecom.app.domain.model.ScreenType
import com.closecom.app.domain.repo.NavigationGateway
import com.closecom.app.domain.repo.messanger.ActiveChatGateway
import com.closecom.app.domain.repo.messanger.ChatsGateway
import javax.inject.Inject
class OpenNewDialogUseCase @Inject constructor(
    private val activeChatGateway: ActiveChatGateway,
    private val navigationGateway: NavigationGateway,
    private val chatsGateway: ChatsGateway
) {
    fun execute(user: User) {
        val chat = chatsGateway.dialogWith(user)
        if (chat.isPresent) {
            activeChatGateway.requestChat(chat.get())
        } else {
            activeChatGateway.requestFakeChat(user)
        }
        navigationGateway.switchScreenWith(ScreenType.CHAT)
    }
}
\end{verbatim}

\subsection{DialogFactory.kt}
\begin{verbatim}
package com.closecom.app.domain.usecase
import android.app.AlertDialog
import android.content.Context
import com.closecom.R
import com.closecom.app.domain.repo.ResourcesGateway
import javax.inject.Inject
class DialogFactory @Inject constructor(
    private val resourcesGateway: ResourcesGateway
) {
    fun createAlertDialog(context: Context, title: String, description
: String): AlertDialog {
        return AlertDialog.Builder(context).apply {
            setTitle(title)
            setMessage(description)
            setPositiveButton(
                resourcesGateway.string(R.string.auth_dialog_confirm))
 { dialog, _ ->
                dialog.cancel()
            }
        }.create()
    }
}
\end{verbatim}

\subsection{AuthInfoValidationUseCase.kt}
\begin{verbatim}
package com.closecom.app.domain.usecase
import com.closecom.app.domain.model.AuthInfo
import javax.inject.Inject
private const val MIN_PASSWORD_LENGTH = 1
class AuthInfoValidationUseCase @Inject constructor() {
    // TODO: Add enum with possible auth info errors.
    fun isInfoValid(authInfo: AuthInfo): Boolean {
        return isEmailValid(authInfo.email) && isPasswordValid(authInf
o.password)
    }
    fun isEmailValid(email: String) = email.contains("@")
    private fun isPasswordValid(password: String) = password.length >=
 MIN_PASSWORD_LENGTH
}
\end{verbatim}

\subsection{OpenChatScreenUseCase.kt}
\begin{verbatim}
package com.closecom.app.domain.usecase
import com.closecom.app.api.domain.model.Chat
import com.closecom.app.domain.model.ScreenType
import com.closecom.app.domain.repo.NavigationGateway
import com.closecom.app.domain.repo.messanger.ActiveChatGateway
import javax.inject.Inject
class OpenChatScreenUseCase @Inject constructor(
    private val activeChatGateway: ActiveChatGateway,
    private val navigationGateway: NavigationGateway
) {
    fun execute(chat: Chat) {
        activeChatGateway.requestChat(chat)
        navigationGateway.openScreen(ScreenType.CHAT)
    }
}
\end{verbatim}

\subsection{LastMessageToDescriptionMapper.kt}
\begin{verbatim}
package com.closecom.app.domain.usecase
import com.closecom.R
import com.closecom.app.api.domain.model.Message
import com.closecom.app.domain.repo.ResourcesGateway
import com.closecom.app.domain.repo.auth.AuthGateway
import javax.inject.Inject
class LastMessageToDescriptionMapper @Inject constructor(
    private val auth: AuthGateway,
    private val resourcesGateway: ResourcesGateway
) {
    operator fun invoke(message: Message): String {
        return message.run {
            "${proceed(from)}: $text"
        }
    }
    private fun proceed(email: String): String {
        return if (email == auth.email()) {
            resourcesGateway.string(R.string.chat_cell_from_me)
        } else {
            email
        }
    }
}
\end{verbatim}

\subsection{LaunchUseCase.kt}
\begin{verbatim}
package com.closecom.app.domain.usecase
import com.closecom.app.domain.model.ScreenType
import com.closecom.app.domain.repo.NavigationGateway
import com.closecom.app.domain.repo.auth.AuthGateway
import javax.inject.Inject
class LaunchUseCase @Inject constructor(
    private val navigationGateway: NavigationGateway,
    private val authGateway: AuthGateway
) {
    fun execute(withReset: Boolean) {
        val current = navigationGateway.screenSync()
        if (!withReset && current.isPresent) {
            navigationGateway.openScreen(current.get())
            return
        }
        val screen = if (authGateway.authorizedSync()) {
            ScreenType.MAIN
        } else {
            ScreenType.AUTH
        }
        navigationGateway.openScreenWithReset(screen)
    }
}
\end{verbatim}

\subsection{SignInUseCase.kt}
\begin{verbatim}
package com.closecom.app.domain.usecase
import com.closecom.app.domain.model.AuthInfo
import com.closecom.app.domain.repo.auth.AuthGateway
import javax.inject.Inject
class SignInUseCase @Inject constructor(
    private val authGateway: AuthGateway,
    private val authInfoValidationUseCase: AuthInfoValidationUseCase
) {
    operator fun invoke(email: String, password: String): Boolean {
        val info = AuthInfo(email, password)
        val isValid = authInfoValidationUseCase.isInfoValid(info)
        if (isValid) {
            authGateway.auth(info)
        }
        return isValid
    }
}
\end{verbatim}

\subsection{SendMessageUseCase.kt}
\begin{verbatim}
package com.closecom.app.domain.usecase.requests
import android.util.Log
import com.closecom.app.api.domain.model.EmptyData
import com.closecom.app.api.domain.repo.ClosecomAPI
import com.closecom.app.domain.repo.auth.TokenGateway
import java.util.Calendar
import javax.inject.Inject
private const val TAG = "FetchSendMessageUseCase"
class FetchSendMessageUseCase @Inject constructor(
    private val baseRequestUseCase: BaseRequestUseCase,
    private val tokenGateway: TokenGateway,
    private val api: ClosecomAPI
) {
    fun execute(
        chatId: Long,
        text: String,
        onSuccess: (EmptyData) -> Unit,
        onError: (Int, String) -> Unit
    ) {
        val token = tokenGateway.token()
        if (!token.isPresent) {
            Log.e(TAG, "invalid token")
            return
        }
        baseRequestUseCase.execute(onSuccess, onError) {
            api.sendMessage(token.get(), chatId, text, Calendar.getIns
tance().timeInMillis)
        }
    }
}
\end{verbatim}

\subsection{StartDialogUseCase.kt}
\begin{verbatim}
package com.closecom.app.domain.usecase.requests
import com.closecom.app.api.domain.repo.ClosecomAPI
import com.closecom.app.domain.repo.auth.TokenGateway
import java.util.Calendar
import javax.inject.Inject
class StartDialogUseCase @Inject constructor(
    private val baseRequestUseCase: BaseRequestUseCase,
    private val tokenGateway: TokenGateway,
    private val api: ClosecomAPI
) {
    fun execute(
        onSuccess: (Long) -> Unit,
        onError: (Int, String) -> Unit,
        userId: Long,
        text: String
    ) {
        baseRequestUseCase.execute(onSuccess, onError) {
            api.startDialog(
                tokenGateway.token().get(),
                userId,
                text,
                Calendar.getInstance().timeInMillis
            )
        }
    }
}
\end{verbatim}

\subsection{SetBidUseCase.kt}
\begin{verbatim}
package com.closecom.app.domain.usecase.requests
import com.closecom.app.api.domain.model.EmptyData
import com.closecom.app.api.domain.repo.ClosecomAPI
import com.closecom.app.domain.repo.auth.TokenGateway
import javax.inject.Inject
class SetBidUseCase @Inject constructor(
    private val baseRequestUseCase: BaseRequestUseCase,
    private val api: ClosecomAPI,
    private val tokenGateway: TokenGateway
) {
    fun execute(
        onSuccess: (EmptyData) -> Unit,
        onError: (Int, String) -> Unit,
        mac: String
    ) {
        baseRequestUseCase.execute(onSuccess, onError) {
            api.bluetoothSetBid(tokenGateway.token().get(), mac)
        }
    }
}
\end{verbatim}

\subsection{FetchUserSearchUseCase.kt}
\begin{verbatim}
package com.closecom.app.domain.usecase.requests
import android.util.Log
import com.closecom.app.api.domain.model.User
import com.closecom.app.api.domain.repo.ClosecomAPI
import com.closecom.app.domain.repo.auth.TokenGateway
import javax.inject.Inject
private const val TAG = "FetchUserSearchUseCase"
class FetchUserSearchUseCase @Inject constructor(
    private val api: ClosecomAPI,
    private val baseRequestUseCase: BaseRequestUseCase,
    private val tokenGateway: TokenGateway
) {
    fun execute(
        pattern: String,
        onSuccess: (List<User>) -> Unit,
        onError: (Int, String) -> Unit
    ) {
        val token = tokenGateway.token()
        if (!token.isPresent) {
            onError(401, "no valid token")
        }
        baseRequestUseCase.execute(onSuccess, onError) {
            Log.d(TAG, "fetch user search with pattern: $pattern")
            api.userSearch(tokenGateway.token().get(), pattern)
        }
    }
}
\end{verbatim}

\subsection{FetchChatsUseCase.kt}
\begin{verbatim}
package com.closecom.app.domain.usecase.requests
import com.closecom.app.api.domain.model.Chat
import com.closecom.app.api.domain.repo.ClosecomAPI
import com.closecom.app.domain.repo.auth.TokenGateway
import javax.inject.Inject
class FetchChatsUseCase @Inject constructor(
    private val tokenGateway: TokenGateway,
    private val api: ClosecomAPI,
    private val baseFetchUseCase: BaseRequestUseCase
) {
    fun execute(
        onSuccess: (List<Chat>) -> Unit,
        onError: (Int, String) -> Unit
    ) {
        val token = tokenGateway.token()
        if (!token.isPresent) {
            onError(401, "No token")
            return
        }
        baseFetchUseCase.execute(onSuccess, onError) {
            api.chats(token.get())
        }
    }
}
\end{verbatim}

\subsection{BaseRequestUseCase.kt}
\begin{verbatim}
package com.closecom.app.domain.usecase.requests
import com.closecom.app.api.domain.model.Response
import com.closecom.app.domain.repo.RequestsExecutor
import javax.inject.Inject
class BaseRequestUseCase @Inject constructor(
    private val requestsExecutor: RequestsExecutor
) {
    fun <T> execute(
        onSuccess: (T) -> Unit,
        onError: (Int, String) -> Unit,
        request: () -> Response<T>
    ) {
        requestsExecutor.execute({
            request()
        }) {
            when (it) {
                is Response.Success -> onSuccess(it.data)
                is Response.Error -> onError(it.responseCode, it.messa
ge)
            }
        }
    }
}
\end{verbatim}

\subsection{FetchMessagesUseCase.kt}
\begin{verbatim}
package com.closecom.app.domain.usecase.requests
import com.closecom.app.api.domain.model.Message
import com.closecom.app.api.domain.repo.ClosecomAPI
import com.closecom.app.domain.repo.auth.TokenGateway
import javax.inject.Inject
class FetchMessagesUseCase @Inject constructor(
    private val baseRequestUseCase: BaseRequestUseCase,
    private val api: ClosecomAPI,
    private val tokenGateway: TokenGateway
) {
    fun execute(
        id: Long,
        onSuccess: (List<Message>) -> Unit,
        onError: (Int, String) -> Unit
    ) {
        val token = tokenGateway.token()
        if (!token.isPresent) {
            onError(401, "No token")
            return
        }
        baseRequestUseCase.execute(onSuccess, onError) {
            api.chatHistory(token.get(), id)
        }
    }
}
\end{verbatim}

\subsection{FetchBluetoothUser.kt}
\begin{verbatim}
package com.closecom.app.domain.usecase.requests
import com.closecom.app.api.domain.model.User
import com.closecom.app.api.domain.repo.ClosecomAPI
import javax.inject.Inject
class FetchBluetoothUser @Inject constructor(
    private val baseRequestUseCase: BaseRequestUseCase,
    private val api: ClosecomAPI
) {
    fun execute(
        onSuccess: (User) -> Unit,
        onError: (Int, String) -> Unit,
        mac: String
    ) {
        baseRequestUseCase.execute(onSuccess, onError) {
            api.bluetoothUserAbout(mac)
        }
    }
}
\end{verbatim}

\subsection{AuthAccountUseCase.kt}
\begin{verbatim}
package com.closecom.app.domain.usecase.requests.auth
import com.closecom.app.api.domain.model.Token
import com.closecom.app.api.domain.repo.ClosecomAPI
import com.closecom.app.domain.usecase.requests.BaseRequestUseCase
import javax.inject.Inject
class AuthAccountUseCase @Inject constructor(
    private val api: ClosecomAPI,
    private val baseRequestUseCase: BaseRequestUseCase
) {
    fun execute(
        onSuccess: (Token) -> Unit,
        onError: (Int, String) -> Unit,
        email: String,
        password: String
    ) {
        baseRequestUseCase.execute(onSuccess, onError) {
            api.authAccount(email, password)
        }
    }
}
\end{verbatim}

\subsection{PasswordRecoveryUseCase.kt}
\begin{verbatim}
package com.closecom.app.domain.usecase.requests.auth
import com.closecom.app.api.domain.model.EmptyData
import com.closecom.app.api.domain.repo.ClosecomAPI
import com.closecom.app.domain.usecase.requests.BaseRequestUseCase
import javax.inject.Inject
class PasswordRecoveryUseCase @Inject constructor(
    private val api: ClosecomAPI,
    private val baseRequestUseCase: BaseRequestUseCase
) {
    fun execute(
        onSuccess: (EmptyData) -> Unit,
        onError: (Int, String) -> Unit,
        email: String
    ) {
        baseRequestUseCase.execute(onSuccess, onError) {
            api.restoreAccountPassword(email)
        }
    }
}
\end{verbatim}

\subsection{AccountDeleteUseCase.kt}
\begin{verbatim}
package com.closecom.app.domain.usecase.requests.auth
import com.closecom.app.api.domain.model.EmptyData
import com.closecom.app.api.domain.repo.ClosecomAPI
import com.closecom.app.domain.usecase.requests.BaseRequestUseCase
import javax.inject.Inject
class AccountDeleteUseCase @Inject constructor(
    private val api: ClosecomAPI,
    private val baseRequestUseCase: BaseRequestUseCase
) {
    fun execute(
        onSuccess: (EmptyData) -> Unit,
        onError: (Int, String) -> Unit,
        token: String
    ) {
        baseRequestUseCase.execute(onSuccess, onError) {
            api.deleteAccount(token)
        }
    }
}
\end{verbatim}

\subsection{CreateAccountUseCase.kt}
\begin{verbatim}
package com.closecom.app.domain.usecase.requests.auth
import com.closecom.app.api.domain.model.Token
import com.closecom.app.api.domain.repo.ClosecomAPI
import com.closecom.app.domain.usecase.requests.BaseRequestUseCase
import javax.inject.Inject
class CreateAccountUseCase @Inject constructor(
    private val api: ClosecomAPI,
    private val baseRequestUseCase: BaseRequestUseCase
) {
    fun execute(
        onSuccess: (Token) -> Unit,
        onError: (Int, String) -> Unit,
        email: String,
        password: String
    ) {
        baseRequestUseCase.execute(onSuccess, onError) {
            api.createAccount(email, password)
        }
    }
}
\end{verbatim}

\subsection{BluetoothGateway.kt}
\begin{verbatim}
package com.closecom.app.domain.repo
import com.closecom.app.domain.model.UserBluetooth
import io.reactivex.rxjava3.core.Flowable
interface BluetoothGateway {
    fun isBluetoothEnabled(): Boolean
    fun usersBluetooth(): Flowable<List<UserBluetooth>>
    fun startScan()
    fun stopScan()
    fun trySetBid()
}
\end{verbatim}

\subsection{NavigationGateway.kt}
\begin{verbatim}
package com.closecom.app.domain.repo
import com.closecom.app.domain.model.ScreenType
import io.reactivex.rxjava3.core.Flowable
import java.util.Optional
interface NavigationGateway {
    fun openScreen(screenType: ScreenType)
    fun openScreenWithReset(screenType: ScreenType)
    fun switchScreenWith(screenType: ScreenType)
    fun navigateBack()
    fun screen(): Flowable<Optional<ScreenType>>
    fun screenSync(): Optional<ScreenType>
}
\end{verbatim}

\subsection{PermissionGateway.kt}
\begin{verbatim}
package com.closecom.app.domain.repo
import io.reactivex.rxjava3.core.Flowable
interface PermissionGateway {
    fun requestPermission(names: List<String>)
    fun hasPermissions(names: List<String>): Boolean
    fun permission(): Flowable<List<String>>
    fun bluetoothPermissions(): List<String>
    fun onResult(isSuccess: Boolean)
}
\end{verbatim}

\subsection{NightModeManager.kt}
\begin{verbatim}
package com.closecom.app.domain.repo
interface NightModeManager
\end{verbatim}

\subsection{MainHandler.kt}
\begin{verbatim}
package com.closecom.app.domain.repo
interface MainHandler {
    fun runOnUi(runnable: () -> Unit)
}
\end{verbatim}

\subsection{SearchUsersGateway.kt}
\begin{verbatim}
package com.closecom.app.domain.repo
import com.closecom.app.api.domain.model.User
import io.reactivex.rxjava3.core.Flowable
interface SearchUsersGateway {
    fun searchResult(): Flowable<List<User>>
    fun loading(): Flowable<Boolean>
    fun requestSearch(pattern: String)
}
\end{verbatim}

\subsection{RequestsExecutor.kt}
\begin{verbatim}
package com.closecom.app.domain.repo
import com.closecom.app.api.domain.model.Response
interface RequestsExecutor {
    fun <R> execute(task: () -> Response<R>, onResult: (Response<R>) -
> Unit)
}
\end{verbatim}

\subsection{SettingsGateway.kt}
\begin{verbatim}
package com.closecom.app.domain.repo
import io.reactivex.rxjava3.core.Flowable
interface SettingsGateway {
    var nightMode: Boolean
    fun nightModeFlowable(): Flowable<Boolean>
}
\end{verbatim}

\subsection{ResourcesGateway.kt}
\begin{verbatim}
package com.closecom.app.domain.repo
import androidx.annotation.StringRes
interface ResourcesGateway {
    fun string(@StringRes id: Int): String
}
\end{verbatim}

\subsection{ExecutorGateway.kt}
\begin{verbatim}
package com.closecom.app.domain.repo
import java.util.concurrent.Future
interface ExecutorGateway {
    fun execute(runnable: () -> Unit)
    fun submit(runnable: () -> Unit): Future<*>
}
\end{verbatim}

\subsection{PreferencesGateway.kt}
\begin{verbatim}
package com.closecom.app.domain.repo
interface PreferencesGateway {
    fun getString(key: String, default: String?): String?
    fun putString(key: String, value: String?)
    fun getBoolean(key: String, default: Boolean): Boolean
    fun putBoolean(key: String, value: Boolean)
}
\end{verbatim}

\subsection{AuthGateway.kt}
\begin{verbatim}
package com.closecom.app.domain.repo.auth
import com.closecom.app.domain.model.AuthInfo
import io.reactivex.rxjava3.core.Flowable
interface AuthGateway {
    fun auth(authInfo: AuthInfo)
    fun createAccount(authInfo: AuthInfo)
    fun deleteAccount()
    fun passwordRecovery(email: String)
    fun authorized(): Flowable<Boolean>
    fun authorizedSync(): Boolean
    fun reset()
    fun email(): String
    fun emailFlowable(): Flowable<String>
}
\end{verbatim}

\subsection{TokenGateway.kt}
\begin{verbatim}
package com.closecom.app.domain.repo.auth
import java.util.Optional
interface TokenGateway {
    fun token(): Optional<String>
}
\end{verbatim}

\subsection{ChatsGateway.kt}
\begin{verbatim}
package com.closecom.app.domain.repo.messanger
import com.closecom.app.api.domain.model.Chat
import com.closecom.app.api.domain.model.User
import io.reactivex.rxjava3.core.Flowable
import java.util.Optional
interface ChatsGateway {
    fun chats(): Flowable<List<Chat>>
    fun updateChats(onUpdated: () -> Unit = {})
    fun dialogWith(user: User): Optional<Chat>
}
\end{verbatim}

\subsection{ActiveChatGateway.kt}
\begin{verbatim}
package com.closecom.app.domain.repo.messanger
import com.closecom.app.api.domain.model.Chat
import com.closecom.app.api.domain.model.Message
import com.closecom.app.api.domain.model.User
import com.closecom.app.domain.model.ActiveChat
import io.reactivex.rxjava3.core.Flowable
import java.util.Optional
interface ActiveChatGateway {
    fun activeChat(): Flowable<Optional<ActiveChat>>
    fun activeChatSync(): ActiveChat
    fun requestChat(chat: Chat)
    fun requestFakeChat(user: User)
    fun isFakeChat(): Flowable<Boolean>
    fun messages(): Flowable<List<Message>>
    fun updateMessages()
    fun sendMessage(text: String)
}
\end{verbatim}

\subsection{ShowActionBarMapper.kt}
\begin{verbatim}
package com.closecom.app.domain.repo.mappers
import com.closecom.app.domain.model.ActionBarModel
import com.closecom.app.domain.model.ScreenType
interface ShowActionBarMapper {
    operator fun invoke(screenType: ScreenType): ActionBarModel
}
\end{verbatim}

\subsection{ScreenMapper.kt}
\begin{verbatim}
package com.closecom.app.domain.repo.mappers
import androidx.fragment.app.Fragment
import com.closecom.app.domain.model.ScreenType
interface ScreenMapper {
    fun fragmentByScreenType(screenType: ScreenType): Fragment
}
\end{verbatim}

\section{Исходный код ресурсов для app}

\subsection{message\_cell\_empty.xml}
\begin{verbatim}
<?xml version="1.0" encoding="utf-8"?>
<FrameLayout xmlns:android="http://schemas.android.com/apk/res/android
"
    android:layout_width="match_parent"
    android:layout_height="match_parent">
    <androidx.appcompat.widget.AppCompatTextView
        android:id="@+id/text_message_cell_empty"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:layout_gravity="center"
        android:text="@string/message_cell_empty"
        android:textColor="@color/default_text"
        android:textSize="18sp" />
</FrameLayout>
\end{verbatim}

\subsection{empty\_cell\_view\_body.xml}
\begin{verbatim}
<?xml version="1.0" encoding="utf-8"?>
<merge xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    xmlns:tools="http://schemas.android.com/tools"
    android:layout_width="match_parent"
    android:layout_height="wrap_content"
    tools:parentTag="androidx.constraintlayout.widget.ConstraintLayout
">
    <TextView
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:layout_margin="@dimen/indent"
        android:text="@string/empty_cell_view_title"
        android:textColor="@color/default_text"
        android:textSize="24sp"
        app:layout_constraintBottom_toBottomOf="parent"
        app:layout_constraintEnd_toEndOf="parent"
        app:layout_constraintStart_toStartOf="parent"
        app:layout_constraintTop_toTopOf="parent" />
</merge>
\end{verbatim}

\subsection{message\_cell.xml}
\begin{verbatim}
<?xml version="1.0" encoding="utf-8"?>
<com.closecom.app.ui.chat.message_list.message_cell.MessageCellViewImp
l xmlns:android="http://schemas.android.com/apk/res/android"
    android:id="@+id/view_message_cell"
    android:layout_width="match_parent"
    android:layout_height="wrap_content" />
\end{verbatim}

\subsection{auth\_fragment\_layout.xml}
\begin{verbatim}
<?xml version="1.0" encoding="utf-8"?>
<androidx.constraintlayout.widget.ConstraintLayout xmlns:android="http
://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    android:layout_width="match_parent"
    android:layout_height="match_parent">
    <androidx.constraintlayout.widget.Guideline
        android:id="@+id/guide_start"
        android:layout_width="0dp"
        android:layout_height="match_parent"
        android:orientation="vertical"
        app:layout_constraintGuide_begin="@dimen/indent_quadruple" />
    <androidx.constraintlayout.widget.Guideline
        android:id="@+id/guide_end"
        android:layout_width="0dp"
        android:layout_height="match_parent"
        android:orientation="vertical"
        app:layout_constraintGuide_end="@dimen/indent_quadruple" />
    <Space
        android:id="@+id/space_centered"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        app:layout_constraintBottom_toBottomOf="parent"
        app:layout_constraintEnd_toEndOf="parent"
        app:layout_constraintStart_toStartOf="parent"
        app:layout_constraintTop_toTopOf="parent" />
    <androidx.appcompat.widget.AppCompatTextView
        android:id="@+id/text_closecom"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:layout_marginTop="100dp"
        android:text="@string/closecom_underlined_name"
        android:textColor="@color/accent"
        android:textSize="62sp"
        app:layout_constraintBottom_toTopOf="@id/edit_email"
        app:layout_constraintEnd_toEndOf="parent"
        app:layout_constraintStart_toStartOf="parent"
        app:layout_constraintTop_toTopOf="parent" />
    <androidx.appcompat.widget.AppCompatEditText
        android:id="@+id/edit_email"
        style="@style/EditText"
        android:layout_width="0dp"
        android:layout_height="wrap_content"
        android:hint="@string/auth_edit_email"
        app:layout_constraintBottom_toTopOf="@id/space_centered"
        app:layout_constraintEnd_toStartOf="@id/guide_end"
        app:layout_constraintStart_toEndOf="@id/guide_start" />
    <androidx.appcompat.widget.AppCompatEditText
        android:id="@+id/edit_password"
        style="@style/EditText"
        android:layout_width="0dp"
        android:layout_height="wrap_content"
        android:layout_marginTop="@dimen/indent"
        android:hint="@string/auth_edit_password"
        android:inputType="textPassword"
        app:layout_constraintEnd_toStartOf="@id/guide_end"
        app:layout_constraintStart_toEndOf="@id/guide_start"
        app:layout_constraintTop_toBottomOf="@id/edit_email" />
    <androidx.appcompat.widget.AppCompatButton
        android:id="@+id/button_sign_in"
        style="@style/PrimaryButton"
        android:layout_width="0dp"
        android:layout_height="@dimen/button_height"
        android:layout_marginTop="@dimen/indent_quadruple"
        android:text="@string/auth_button_sign_in"
        app:layout_constraintEnd_toStartOf="@id/guide_end"
        app:layout_constraintStart_toEndOf="@id/guide_start"
        app:layout_constraintTop_toBottomOf="@id/edit_password" />
    <androidx.appcompat.widget.AppCompatButton
        android:id="@+id/button_sign_up"
        style="@style/OutlineButton"
        android:layout_width="0dp"
        android:layout_height="@dimen/button_height"
        android:layout_marginTop="@dimen/indent"
        android:text="@string/auth_button_sign_up"
        app:layout_constraintEnd_toStartOf="@id/guide_end"
        app:layout_constraintStart_toEndOf="@id/guide_start"
        app:layout_constraintTop_toBottomOf="@id/button_sign_in" />
    <androidx.appcompat.widget.AppCompatButton
        android:id="@+id/button_forgot_password"
        style="@style/TextButton"
        android:layout_width="0dp"
        android:layout_height="@dimen/button_height"
        android:layout_marginTop="16dp"
        android:text="@string/auth_button_forgot_password"
        app:layout_constraintEnd_toStartOf="@id/guide_end"
        app:layout_constraintStart_toEndOf="@id/guide_start"
        app:layout_constraintTop_toBottomOf="@id/button_sign_up" />
</androidx.constraintlayout.widget.ConstraintLayout>
\end{verbatim}

\subsection{search\_body.xml}
\begin{verbatim}
<?xml version="1.0" encoding="utf-8"?>
<merge xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    xmlns:tools="http://schemas.android.com/tools"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    tools:parentTag="androidx.constraintlayout.widget.ConstraintLayout
">
    <androidx.appcompat.widget.AppCompatEditText
        android:id="@+id/edit_user_name"
        style="@style/MessageEditText"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:layout_marginHorizontal="@dimen/indent_double"
        android:layout_marginTop="@dimen/indent_double"
        android:hint="@string/search_edit_text_hint"
        android:inputType="textFilter"
        android:textSize="20sp"
        app:layout_constraintEnd_toEndOf="parent"
        app:layout_constraintStart_toStartOf="parent"
        app:layout_constraintTop_toTopOf="parent" />
    <include
        android:id="@+id/view_splitter"
        layout="@layout/splitter_view"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:layout_marginTop="@dimen/indent_double"
        app:layout_constraintEnd_toEndOf="parent"
        app:layout_constraintStart_toStartOf="parent"
        app:layout_constraintTop_toBottomOf="@id/edit_user_name" />
    <androidx.recyclerview.widget.RecyclerView
        android:id="@+id/recycler_search_result"
        android:layout_width="match_parent"
        android:layout_height="0dp"
        app:layout_constraintBottom_toBottomOf="parent"
        app:layout_constraintEnd_toEndOf="parent"
        app:layout_constraintStart_toStartOf="parent"
        app:layout_constraintTop_toBottomOf="@id/view_splitter" />
</merge>
\end{verbatim}

\subsection{chat\_fragment\_layout.xml}
\begin{verbatim}
<?xml version="1.0" encoding="utf-8"?>
<androidx.constraintlayout.widget.ConstraintLayout xmlns:android="http
://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    android:layout_width="match_parent"
    android:layout_height="match_parent">
    <com.closecom.app.ui.chat.message_list.MessageListViewImpl
        android:id="@+id/view_message_list"
        android:layout_width="match_parent"
        android:layout_height="0dp"
        app:layout_constraintBottom_toTopOf="@id/group_bottom"
        app:layout_constraintEnd_toEndOf="parent"
        app:layout_constraintStart_toStartOf="parent"
        app:layout_constraintTop_toTopOf="parent" />
    <androidx.constraintlayout.widget.ConstraintLayout
        android:id="@+id/group_bottom"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        app:layout_constraintBottom_toBottomOf="parent"
        app:layout_constraintEnd_toEndOf="@id/view_message_list"
        app:layout_constraintStart_toStartOf="@id/view_message_list">
        <androidx.appcompat.widget.AppCompatEditText
            android:id="@+id/edit_chat_message"
            style="@style/MessageEditText"
            android:layout_width="0dp"
            android:layout_height="wrap_content"
            android:paddingVertical="@dimen/indent_half"
            android:layout_marginStart="@dimen/indent_double"
            android:layout_marginTop="@dimen/indent"
            android:layout_marginEnd="@dimen/indent"
            android:layout_marginBottom="@dimen/indent_double"
            android:hint="@string/chat_input_text_hint"
            android:textSize="18sp"
            app:layout_constraintBottom_toBottomOf="parent"
            app:layout_constraintEnd_toStartOf="@id/button_send_messag
e"
            app:layout_constraintStart_toStartOf="parent"
            app:layout_constraintTop_toTopOf="parent" />
        <androidx.appcompat.widget.AppCompatButton
            android:id="@+id/button_send_message"
            android:layout_width="40dp"
            android:layout_height="40dp"
            android:layout_marginEnd="@dimen/indent"
            android:background="@drawable/ic_send"
            app:layout_constraintBottom_toBottomOf="@id/edit_chat_mess
age"
            app:layout_constraintEnd_toEndOf="parent" />
    </androidx.constraintlayout.widget.ConstraintLayout>
</androidx.constraintlayout.widget.ConstraintLayout>
\end{verbatim}

\subsection{search\_fragment\_layout.xml}
\begin{verbatim}
<?xml version="1.0" encoding="utf-8"?>
<androidx.swiperefreshlayout.widget.SwipeRefreshLayout
    android:id="@+id/layout_refresher"
    xmlns:android="http://schemas.android.com/apk/res/android" android
:layout_width="match_parent"
    android:layout_height="match_parent">
    <com.closecom.app.ui.search.SearchViewImpl
        android:id="@+id/view_search"
        android:layout_width="match_parent"
        android:layout_height="match_parent" />
</androidx.swiperefreshlayout.widget.SwipeRefreshLayout>
\end{verbatim}

\subsection{search\_user\_loading.xml}
\begin{verbatim}
<?xml version="1.0" encoding="utf-8"?>
<FrameLayout xmlns:android="http://schemas.android.com/apk/res/android
"
    android:layout_width="match_parent"
    android:layout_height="match_parent">
    <ProgressBar
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:layout_gravity="center"
        android:layout_margin="@dimen/indent" />
</FrameLayout>
\end{verbatim}

\subsection{develop\_fragment\_layout.xml}
\begin{verbatim}
<?xml version="1.0" encoding="utf-8"?>
<androidx.constraintlayout.widget.ConstraintLayout xmlns:android="http
://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    xmlns:app="http://schemas.android.com/apk/res-auto">
    <androidx.recyclerview.widget.RecyclerView
        android:id="@+id/recycler_view_dev"
        android:layout_width="match_parent"
        android:layout_height="match_parent"
        app:layout_constraintBottom_toBottomOf="parent"
        app:layout_constraintEnd_toEndOf="parent"
        app:layout_constraintStart_toStartOf="parent"
        app:layout_constraintTop_toTopOf="parent" />
</androidx.constraintlayout.widget.ConstraintLayout>
\end{verbatim}

\subsection{empty\_cell\_view.xml}
\begin{verbatim}
<?xml version="1.0" encoding="utf-8"?>
<com.closecom.app.ui.chat_list.empty_cell.EmptyCellView xmlns:android=
"http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="match_parent" /
\end{verbatim}

\subsection{message\_cell\_loading.xml}
\begin{verbatim}
<?xml version="1.0" encoding="utf-8"?>
<FrameLayout xmlns:android="http://schemas.android.com/apk/res/android
"
    android:layout_width="match_parent"
    android:layout_height="match_parent">
    <ProgressBar
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:layout_gravity="center" />
</FrameLayout>
\end{verbatim}

\subsection{splitter\_view.xml}
\begin{verbatim}
<?xml version="1.0" encoding="utf-8"?>
<androidx.appcompat.widget.AppCompatImageView xmlns:android="http://sc
hemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="wrap_content"
    android:background="@drawable/line_slpitter" />
\end{verbatim}

\subsection{chat\_cell\_body.xml}
\begin{verbatim}
<?xml version="1.0" encoding="utf-8"?>
<merge xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    xmlns:tools="http://schemas.android.com/tools"
    android:layout_width="match_parent"
    android:layout_height="@dimen/chat_cell_height"
    tools:parentTag="androidx.constraintlayout.widget.ConstraintLayout
">
    <androidx.appcompat.widget.AppCompatTextView
        android:id="@+id/text_title"
        android:layout_width="0dp"
        android:layout_height="wrap_content"
        android:layout_marginStart="20dp"
        android:layout_marginTop="20dp"
        android:textColor="@color/chat_cell_text"
        android:textSize="20sp"
        app:layout_constraintEnd_toStartOf="@id/text_date"
        app:layout_constraintHorizontal_chainStyle="spread"
        app:layout_constraintStart_toStartOf="parent"
        app:layout_constraintTop_toTopOf="parent"
        tools:text="Simon Biden" />
    <androidx.appcompat.widget.AppCompatTextView
        android:id="@+id/text_date"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:layout_marginEnd="18sp"
        android:textColor="@color/chat_cell_text_secondary"
        android:textSize="18sp"
        app:layout_constraintEnd_toEndOf="parent"
        app:layout_constraintTop_toTopOf="@id/text_title"
        tools:text="Jan 16, 17:33" />
    <androidx.appcompat.widget.AppCompatTextView
        android:id="@+id/text_description"
        android:layout_width="0dp"
        android:layout_height="wrap_content"
        android:ellipsize="end"
        android:maxLines="1"
        android:textColor="@color/chat_cell_text_secondary"
        android:textSize="18sp"
        app:layout_constraintBottom_toBottomOf="parent"
        app:layout_constraintEnd_toEndOf="@id/text_date"
        app:layout_constraintStart_toStartOf="@id/text_title"
        app:layout_constraintTop_toBottomOf="@id/text_title"
        tools:text="Simon Biden: Don\xe2\x80\x99t tread on me..." />
</merge>
\end{verbatim}

\subsection{message\_cell\_body.xml}
\begin{verbatim}
<?xml version="1.0" encoding="utf-8"?>
<merge xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    xmlns:tools="http://schemas.android.com/tools"
    android:id="@+id/view_message_cell_root"
    android:layout_width="match_parent"
    android:layout_height="wrap_content"
    tools:parentTag="androidx.constraintlayout.widget.ConstraintLayout
">
    <FrameLayout
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:layout_marginHorizontal="@dimen/indent_double"
        android:paddingTop="@dimen/indent_half"
        app:layout_constraintBottom_toBottomOf="parent"
        app:layout_constraintEnd_toEndOf="parent"
        app:layout_constraintStart_toStartOf="parent"
        app:layout_constraintTop_toTopOf="parent">
        <com.closecom.app.ui.chat.message_list.message_view.MessageVie
wImpl
            android:id="@+id/view_message"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:layout_gravity="start"
            android:background="@drawable/message_background"
            android:minWidth="100dp"
            android:visibility="invisible"
            tools:visibility="visible" />
    </FrameLayout>
</merge>
\end{verbatim}

\subsection{search\_user\_cell.xml}
\begin{verbatim}
<?xml version="1.0" encoding="utf-8"?>
<com.closecom.app.ui.search.SearchCellView xmlns:android="http://schem
as.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="wrap_content" />
\end{verbatim}

\subsection{search\_user\_hint.xml}
\begin{verbatim}
<?xml version="1.0" encoding="utf-8"?>
<FrameLayout xmlns:android="http://schemas.android.com/apk/res/android
"
    android:layout_width="match_parent"
    android:layout_height="match_parent">
    <androidx.appcompat.widget.AppCompatTextView
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:layout_gravity="center"
        android:text="@string/search_user_hint"
        android:textColor="@color/default_text"
        android:textSize="@dimen/default_text_size" />
</FrameLayout>
\end{verbatim}

\subsection{main\_fragment\_layout.xml}
\begin{verbatim}
<?xml version="1.0" encoding="utf-8"?>
<androidx.swiperefreshlayout.widget.SwipeRefreshLayout xmlns:android="
http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    android:id="@+id/layout_refresh"
    android:layout_width="match_parent"
    android:layout_height="match_parent">
    <com.closecom.app.ui.chat_list.ChatListViewImpl
        android:id="@+id/view_chat_list"
        android:layout_width="match_parent"
        android:layout_height="0dp"
        app:layout_constraintBottom_toBottomOf="parent"
        app:layout_constraintEnd_toEndOf="parent"
        app:layout_constraintStart_toStartOf="parent"
        app:layout_constraintTop_toTopOf="parent" />
</androidx.swiperefreshlayout.widget.SwipeRefreshLayout>
\end{verbatim}

\subsection{bluetooth\_fragment\_layout.xml}
\begin{verbatim}
<?xml version="1.0" encoding="utf-8"?>
<androidx.constraintlayout.widget.ConstraintLayout xmlns:android="http
://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="match_parent">
    <androidx.recyclerview.widget.RecyclerView
        android:id="@+id/recycler_bluetooth_search"
        android:layout_width="match_parent"
        android:layout_height="match_parent" />
</androidx.constraintlayout.widget.ConstraintLayout>
\end{verbatim}

\subsection{bluetooth\_cell\_loading.xml}
\begin{verbatim}
<?xml version="1.0" encoding="utf-8"?>
<FrameLayout xmlns:android="http://schemas.android.com/apk/res/android
"
    android:layout_width="match_parent"
    android:layout_height="match_parent">
    <LinearLayout
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:layout_gravity="center"
        android:orientation="vertical">
        <androidx.appcompat.widget.AppCompatTextView
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:text="@string/bluetooth_scanning"
            android:textColor="@color/default_text"
            android:textSize="22sp" />
        <ProgressBar
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:layout_gravity="center"
            android:layout_margin="@dimen/indent"
            android:layout_marginTop="@dimen/indent" />
    </LinearLayout>
</FrameLayout>
\end{verbatim}

\subsection{chat\_list\_body.xml}
\begin{verbatim}
<?xml version="1.0" encoding="utf-8"?>
<merge xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    android:layout_width="match_parent"
    android:layout_height="match_parent">
    <ProgressBar
        android:id="@+id/progress_bar"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        app:layout_constraintBottom_toBottomOf="parent"
        app:layout_constraintEnd_toEndOf="parent"
        app:layout_constraintStart_toStartOf="parent"
        app:layout_constraintTop_toTopOf="parent" />
    <androidx.recyclerview.widget.RecyclerView
        android:id="@+id/recycler_chat_list"
        android:layout_width="match_parent"
        android:layout_height="match_parent"
        android:clipToPadding="false"
        app:layout_constraintBottom_toBottomOf="parent"
        app:layout_constraintEnd_toEndOf="parent"
        app:layout_constraintStart_toStartOf="parent"
        app:layout_constraintTop_toTopOf="parent"
        android:visibility="gone"/>
</merge>
\end{verbatim}

\subsection{settings\_cell\_body.xml}
\begin{verbatim}
<?xml version="1.0" encoding="utf-8"?>
<merge xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    xmlns:tools="http://schemas.android.com/tools"
    android:layout_width="match_parent"
    android:layout_height="wrap_content"
    tools:parentTag="androidx.constraintlayout.widget.ConstraintLayout
">
    <androidx.appcompat.widget.AppCompatTextView
        android:id="@+id/text_title"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:layout_marginStart="@dimen/indent_double"
        android:layout_marginTop="@dimen/indent_double"
        android:layout_marginBottom="@dimen/indent_double"
        android:textColor="@color/default_text"
        android:textSize="@dimen/default_text_size"
        app:layout_constraintBottom_toBottomOf="parent"
        app:layout_constraintStart_toStartOf="parent"
        app:layout_constraintTop_toTopOf="parent"
        tools:text="Some setting" />
    <androidx.appcompat.widget.SwitchCompat
        android:id="@+id/switch_settings"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:layout_marginEnd="@dimen/indent_double"
        android:visibility="gone"
        app:layout_constraintBottom_toBottomOf="@id/text_title"
        app:layout_constraintEnd_toEndOf="parent"
        app:layout_constraintTop_toTopOf="@id/text_title"
        tools:visibility="visible" />
</merge>
\end{verbatim}

\subsection{message\_list\_body.xml}
\begin{verbatim}
<?xml version="1.0" encoding="utf-8"?>
<merge xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    xmlns:tools="http://schemas.android.com/tools"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    tools:parentTag="androidx.constraintlayout.widget.ConstraintLayout
">
    <androidx.recyclerview.widget.RecyclerView
        android:id="@+id/recycler_messages_list"
        android:layout_width="match_parent"
        android:layout_height="match_parent"
        app:layout_constraintBottom_toBottomOf="parent"
        app:layout_constraintEnd_toEndOf="parent"
        app:layout_constraintStart_toStartOf="parent"
        app:layout_constraintTop_toTopOf="parent" />
</merge>
\end{verbatim}

\subsection{search\_user\_cell\_body.xml}
\begin{verbatim}
<?xml version="1.0" encoding="utf-8"?>
<merge xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    xmlns:tools="http://schemas.android.com/tools"
    android:layout_width="match_parent"
    android:layout_height="wrap_content"
    tools:parentTag="androidx.constraintlayout.widget.ConstraintLayout
">
    <androidx.appcompat.widget.AppCompatTextView
        android:id="@+id/text_user_name"
        android:layout_width="0dp"
        android:layout_height="wrap_content"
        android:paddingVertical="@dimen/indent_double"
        android:gravity="start"
        android:paddingHorizontal="@dimen/indent_double"
        android:textColor="@color/default_text"
        android:textSize="18sp"
        app:layout_constraintBottom_toBottomOf="parent"
        app:layout_constraintEnd_toEndOf="parent"
        app:layout_constraintStart_toStartOf="parent"
        app:layout_constraintTop_toTopOf="parent"
        tools:text="email@example.com" />
</merge>
\end{verbatim}

\subsection{menu\_cell.xml}
\begin{verbatim}
<?xml version="1.0" encoding="utf-8"?>
<com.closecom.app.ui.common.menu.MenuCellView xmlns:android="http://sc
hemas.android.com/apk/res/android"
    android:id="@+id/view_settings_cell"
    android:layout_width="match_parent"
    android:layout_height="wrap_content" />
\end{verbatim}

\subsection{message\_cell\_start.xml}
\begin{verbatim}
<?xml version="1.0" encoding="utf-8"?>
<FrameLayout xmlns:android="http://schemas.android.com/apk/res/android
"
    android:layout_width="match_parent"
    android:layout_height="match_parent">
    <androidx.appcompat.widget.AppCompatTextView
        android:id="@+id/text_message_cell_hint"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:layout_gravity="center"
        android:layout_marginHorizontal="@dimen/indent_double"
        android:gravity="center"
        android:text="@string/message_cell_start"
        android:textColor="@color/default_text"
        android:textSize="20sp" />
</FrameLayout>
\end{verbatim}

\subsection{bluetooth\_cell\_body.xml}
\begin{verbatim}
<?xml version="1.0" encoding="utf-8"?>
<merge xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    xmlns:tools="http://schemas.android.com/tools"
    android:layout_width="match_parent"
    android:layout_height="wrap_content"
    tools:parentTag="androidx.constraintlayout.widget.ConstraintLayout
">
    <androidx.appcompat.widget.AppCompatTextView
        android:id="@+id/text_title"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:layout_marginStart="@dimen/indent"
        android:layout_marginTop="@dimen/indent"
        android:textColor="@color/default_text"
        android:textSize="@dimen/default_text_size"
        app:layout_constraintStart_toStartOf="parent"
        app:layout_constraintTop_toTopOf="parent"
        tools:text="John John" />
    <androidx.appcompat.widget.AppCompatTextView
        android:id="@+id/text_bid"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:layout_marginTop="@dimen/indent"
        android:layout_marginBottom="@dimen/indent"
        android:textColor="@color/default_text"
        android:textSize="@dimen/default_text_size"
        app:layout_constraintBottom_toBottomOf="parent"
        app:layout_constraintStart_toStartOf="@id/text_title"
        app:layout_constraintTop_toBottomOf="@id/text_title"
        tools:text="32:4f:54:h7:4f" />
</merge
\end{verbatim}

\subsection{bluetooth\_cell.xml}
\begin{verbatim}
<?xml version="1.0" encoding="utf-8"?>
<com.closecom.app.ui.bluetooth.BluetoothCellView xmlns:android="http:/
/schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="wrap_content" />
\end{verbatim}

\subsection{message\_view\_body.xml}
\begin{verbatim}
<?xml version="1.0" encoding="utf-8"?>
<merge xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    xmlns:tools="http://schemas.android.com/tools"
    android:layout_width="wrap_content"
    android:layout_height="wrap_content"
    tools:parentTag="androidx.constraintlayout.widget.ConstraintLayout
">
    <androidx.appcompat.widget.AppCompatTextView
        android:id="@+id/text_message"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:layout_marginStart="@dimen/indent"
        android:layout_marginTop="10dp"
        android:layout_marginEnd="@dimen/indent"
        android:textColor="#FFF"
        android:textAlignment="textStart"
        android:maxWidth="220dp"
        android:textSize="@dimen/default_text_size"
        app:layout_constraintEnd_toEndOf="parent"
        app:layout_constraintStart_toStartOf="parent"
        app:layout_constraintTop_toTopOf="parent"
        tools:text="\xd0\x9f\xd1\x80\xd0\xb8\xd0\xb2\xd0\xb5\xd1\x82 \xd0\xba\xd0\xb0\xd0\xba \xd0\xb4\xd0\xb5\xd0\xbb\xd0\xb0?" />
    <androidx.appcompat.widget.AppCompatTextView
        android:id="@+id/text_date"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:layout_marginTop="10dp"
        android:layout_marginEnd="@dimen/indent"
        android:layout_marginBottom="10dp"
        android:textSize="16sp"
        android:textColor="#FFFFFF"
        app:layout_constraintBottom_toBottomOf="parent"
        app:layout_constraintEnd_toEndOf="parent"
        app:layout_constraintTop_toBottomOf="@id/text_message"
        tools:text="12:15" />
</merge>
\end{verbatim}

\subsection{settings\_fragment\_layout.xml}
\begin{verbatim}
<?xml version="1.0" encoding="utf-8"?>
<androidx.constraintlayout.widget.ConstraintLayout xmlns:android="http
://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    android:layout_width="match_parent"
    android:layout_height="match_parent">
    <androidx.recyclerview.widget.RecyclerView
        android:id="@+id/recycler_view_settings"
        android:layout_width="match_parent"
        android:layout_height="match_parent"
        app:layout_constraintBottom_toBottomOf="parent"
        app:layout_constraintEnd_toEndOf="parent"
        app:layout_constraintStart_toStartOf="parent"
        app:layout_constraintTop_toTopOf="parent" />
</androidx.constraintlayout.widget.ConstraintLayout>
\end{verbatim}

\subsection{chat\_cell.xml}
\begin{verbatim}
<?xml version="1.0" encoding="utf-8"?>
<com.closecom.app.ui.chat_list.chat_cell.ChatCellViewImpl xmlns:androi
d="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="@dimen/chat_cell_height" />
\end{verbatim}

\subsection{activity\_main.xml}
\begin{verbatim}
<?xml version="1.0" encoding="utf-8"?>
<androidx.drawerlayout.widget.DrawerLayout xmlns:android="http://schem
as.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    xmlns:tools="http://schemas.android.com/tools"
    android:id="@+id/drawer_layout"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    tools:context=".app.ui.MainActivity"
    tools:openDrawer="start">
    <androidx.constraintlayout.widget.ConstraintLayout
        android:layout_width="match_parent"
        android:layout_height="match_parent">
        <androidx.appcompat.widget.Toolbar
            android:id="@+id/top_toolbar"
            style="@style/Toolbar"
            android:layout_width="match_parent"
            android:layout_height="?attr/actionBarSize"
            android:theme="@style/ThemeOverlay.AppCompat.ActionBar"
            app:layout_constraintEnd_toEndOf="parent"
            app:layout_constraintStart_toStartOf="parent"
            app:layout_constraintTop_toTopOf="parent"
            app:popupTheme="@style/ThemeOverlay.AppCompat.DayNight" />
        <FrameLayout
            android:id="@+id/root_layout"
            android:layout_width="match_parent"
            android:layout_height="0dp"
            app:layout_constraintBottom_toBottomOf="parent"
            app:layout_constraintTop_toBottomOf="@id/top_toolbar" />
    </androidx.constraintlayout.widget.ConstraintLayout>
    <com.closecom.app.ui.slide_menu.SlideMenuViewImpl
        android:id="@+id/slide_view"
        android:layout_width="match_parent"
        android:layout_height="match_parent"
        android:layout_gravity="start"
        android:background="@color/background" />
</androidx.drawerlayout.widget.DrawerLayout>
\end{verbatim}

\subsection{slide\_view\_body.xml}
\begin{verbatim}
<?xml version="1.0" encoding="utf-8"?>
<merge xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    xmlns:tools="http://schemas.android.com/tools"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    tools:parentTag="androidx.constraintlayout.widget.ConstraintLayout
">
    <androidx.appcompat.widget.AppCompatTextView
        android:id="@+id/text_slide_title"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:layout_marginTop="@dimen/indent_double"
        android:textColor="@color/default_text"
        android:textSize="22sp"
        android:textStyle="bold"
        app:layout_constraintEnd_toEndOf="parent"
        app:layout_constraintStart_toStartOf="parent"
        app:layout_constraintTop_toTopOf="parent"
        tools:text="email@example.com" />
    <include
        android:id="@+id/view_splitter"
        layout="@layout/splitter_view"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:layout_marginTop="@dimen/indent_double"
        app:layout_constraintEnd_toEndOf="parent"
        app:layout_constraintStart_toStartOf="parent"
        app:layout_constraintTop_toBottomOf="@id/text_slide_title" />
    <androidx.recyclerview.widget.RecyclerView
        android:id="@+id/recycler_slide_list"
        android:layout_width="match_parent"
        android:layout_height="0dp"
        app:layout_constraintBottom_toBottomOf="parent"
        app:layout_constraintEnd_toEndOf="parent"
        app:layout_constraintStart_toStartOf="parent"
        app:layout_constraintTop_toBottomOf="@id/view_splitter" />
</merge>
\end{verbatim}

\subsection{search\_user\_empty.xml}
\begin{verbatim}
<?xml version="1.0" encoding="utf-8"?>
<FrameLayout xmlns:android="http://schemas.android.com/apk/res/android
"
    android:layout_width="match_parent"
    android:layout_height="match_parent">
    <androidx.appcompat.widget.AppCompatTextView
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:layout_gravity="center"
        android:text="@string/search_user_empty_title"
        android:textColor="@color/default_text"
        android:textSize="@dimen/default_text_size" />
</FrameLayout>
\end{verbatim}

\section{Исходный код тестов для app}

\subsection{TimeWrapperUseCaseTest.kt}
\begin{verbatim}
package com.closecom.app.domain.usecase
import java.util.Locale
import org.junit.Assert
import org.junit.Test
internal class TimeWrapperUseCaseTest {
    private val mapper = TimestampToTimeMapper(Locale.ROOT)
    @Test
    fun format() {
        val cases = listOf(
            1616858199000L to "18:16",
            1616858997000L to "18:29",
            1616859024000L to "18:30"
        )
        for ((timestamp, expected) in cases) {
            val actual = mapper(timestamp)
            Assert.assertEquals(expected, actual)
        }
    }
}
\end{verbatim}

\section{Исходный код модуля api}

\subsection{Assert.kt}
\begin{verbatim}
package com.closecom.app.api.utils
import android.os.Looper
import com.closecom.api.BuildConfig
fun assertNotUi() {
    if (BuildConfig.DEBUG && Looper.getMainLooper().thread == Thread.c
urrentThread()) {
        error("Assert on worker thread")
    }
}
fun assertUi() {
    if (BuildConfig.DEBUG && Looper.getMainLooper().thread != Thread.c
urrentThread()) {
        error("Assert on Ui thread")
    }
}
\end{verbatim}

\subsection{ClosecomAPIImpl.kt}
\begin{verbatim}
package com.closecom.app.api.data.repo
import com.closecom.app.api.domain.model.Chat
import com.closecom.app.api.domain.model.EmptyData
import com.closecom.app.api.domain.model.Message
import com.closecom.app.api.domain.model.RequestType
import com.closecom.app.api.domain.model.Response
import com.closecom.app.api.domain.model.Token
import com.closecom.app.api.domain.model.User
import com.closecom.app.api.domain.parsers.ChatHistoryParser
import com.closecom.app.api.domain.parsers.ChatsParser
import com.closecom.app.api.domain.parsers.UserParser
import com.closecom.app.api.domain.parsers.UserSearchParser
import com.closecom.app.api.domain.repo.ClosecomAPI
import com.closecom.app.api.domain.repo.requests.Request
import com.closecom.app.api.domain.repo.requests.RequestsBuilderFactor
y
import org.json.JSONObject
import javax.inject.Inject
private const val API_URL = "http://35.233.172.230"
class ClosecomAPIImpl @Inject constructor(
    private val requestsBuilderFactory: RequestsBuilderFactory,
    private val userSearchParser: UserSearchParser,
    private val chatsParser: ChatsParser,
    private val chatsHistoryParser: ChatHistoryParser,
    private val userParser: UserParser
) : ClosecomAPI {
    override fun createAccount(email: String, password: String): Respo
nse<Token> {
        val request = requestsBuilderFactory.createBuilder()
            .setUrl("$API_URL/account/create")
            .setRequestType(RequestType.POST)
            .setHeaderProperty("Content-Type" to "application/json")
            .setHeaderProperty("Accept" to "application/json")
            .setJsonBody(
                mapOf("email" to email, "password" to password)
            )
            .build()
        return executeRequest(request) {
            Response.Success(Token(it.getString("token")))
        }
    }
    override fun authAccount(email: String, password: String): Respons
e<Token> {
        val request = requestsBuilderFactory.createBuilder()
            .setUrl("$API_URL/account/auth")
            .setRequestType(RequestType.POST)
            .setHeaderProperty("Content-Type" to "application/json")
            .setHeaderProperty("Accept" to "application/json")
            .setJsonBody(
                mapOf("email" to email, "password" to password)
            )
            .build()
        return executeRequest(request) {
            Response.Success(Token(it.getString("token")))
        }
    }
    override fun deleteAccount(token: String): Response<EmptyData> {
        val request = requestsBuilderFactory.createBuilder()
            .setUrl("$API_URL/account/delete")
            .setRequestType(RequestType.POST)
            .setHeaderProperty("Accept" to "application/json")
            .setParam("token" to token)
            .build()
        return executeRequest(request) {
            Response.Success(EmptyData.instance)
        }
    }
    override fun restoreAccountPassword(email: String): Response<Empty
Data> {
        val request = requestsBuilderFactory.createBuilder()
            .setUrl("$API_URL/account/recovery")
            .setRequestType(RequestType.POST)
            .setHeaderProperty("Accept" to "application/json")
            .setParam("email" to email)
            .build()
        return executeRequest(request) {
            Response.Success(EmptyData.instance)
        }
    }
    override fun chats(token: String): Response<List<Chat>> {
        val request = requestsBuilderFactory.createBuilder()
            .setUrl("$API_URL/messenger/chats")
            .setRequestType(RequestType.GET)
            .setHeaderProperty("Content-Type" to "application/json")
            .setParam("token" to token)
            .build()
        return executeRequest(request) {
            Response.Success(chatsParser.parse(it))
        }
    }
    override fun chatHistory(token: String, chatId: Long): Response<Li
st<Message>> {
        val request = requestsBuilderFactory.createBuilder()
            .setUrl("$API_URL/messenger/chat_history")
            .setRequestType(RequestType.GET)
            .setHeaderProperty("Content-Type" to "application/json")
            .setParam("token" to token)
            .setParam("chat_id" to chatId.toString())
            .build()
        return executeRequest(request) {
            Response.Success(chatsHistoryParser.parse(it))
        }
    }
    override fun startDialog(
        token: String,
        userId: Long,
        text: String,
        time: Long
    ): Response<Long> {
        val request = requestsBuilderFactory.createBuilder()
            .setUrl("$API_URL/messenger/start_dialog")
            .setRequestType(RequestType.POST)
            .setHeaderProperty("Content-Type" to "application/json")
            .setParam("token" to token)
            .setParam("user_id" to userId.toString())
            .setJsonBody(
                mapOf("text" to text, "time" to "$time")
            )
            .build()
        return executeRequest(request) {
            Response.Success(it.getLong("chat_id"))
        }
    }
    override fun userSearch(token: String, email: String): Response<Li
st<User>> {
        val request = requestsBuilderFactory.createBuilder()
            .setUrl("$API_URL/messenger/user_search")
            .setRequestType(RequestType.GET)
            .setParam("token" to token)
            .setParam("email" to email)
            .setHeaderProperty("Content-Type" to "application/json")
            .build()
        return executeRequest(request) {
            Response.Success(userSearchParser.parse(it))
        }
    }
    override fun createChat(token: String, users: List<Long>): Respons
e<Long> {
        return Response.Error(401, "Not implemented")
    }
    override fun sendMessage(
        token: String,
        chatId: Long,
        text: String,
        time: Long
    ): Response<EmptyData> {
        val request = requestsBuilderFactory.createBuilder()
            .setUrl("$API_URL/messenger/send_message")
            .setRequestType(RequestType.POST)
            .setHeaderProperty("Content-Type" to "application/json")
            .setParam("token" to token)
            .setParam("chat_id" to chatId.toString())
            .setJsonBody(mapOf("text" to text, "time" to time.toString
()))
            .build()
        return executeRequest(request) {
            Response.Success(EmptyData.instance)
        }
    }
    override fun deleteMessage(token: String, messageId: Long): Respon
se<EmptyData> {
        return Response.Error(401, "Not implemented")
    }
    override fun deleteChat(token: String, chatId: Long): Response<Emp
tyData> {
        return Response.Error(401, "Not implemented")
    }
    override fun bluetoothUserAbout(bid: String): Response<User> {
        val request = requestsBuilderFactory.createBuilder()
            .setUrl("$API_URL/bluetooth/user_about")
            .setRequestType(RequestType.GET)
            .setHeaderProperty("Content-Type" to "application/json")
            .setParam("bid" to bid)
            .build()
        return executeRequest(request) {
            Response.Success(userParser.parse(it))
        }
    }
    override fun bluetoothSetBid(token: String, bid: String): Response
<EmptyData> {
        val request = requestsBuilderFactory.createBuilder()
            .setUrl("$API_URL/bluetooth/set_bid")
            .setRequestType(RequestType.POST)
            .setHeaderProperty("Content-Type" to "application/json")
            .setParam("token" to token)
            .setParam("bid" to bid)
            .build()
        return executeRequest(request) {
            Response.Success(EmptyData.instance)
        }
    }
    private fun <T> executeRequest(
        request: Request,
        onSuccess: (JSONObject) -> Response.Success<T>
    ): Response<T> {
        return request.execute().run {
            if (isSuccess) {
                onSuccess(jsonObject)
            } else {
                val message =
                    if (jsonObject.isNull("error_message")) "" else js
onObject.getString("error_message")
                Response.Error(responseCode, message)
            }
        }
    }
}
\end{verbatim}

\subsection{MessagesStorage.kt}
\begin{verbatim}
package com.closecom.app.api.data.repo.mvp
import com.closecom.app.api.domain.model.Chat
import com.closecom.app.api.domain.model.Message
import com.closecom.app.api.domain.model.User
import com.closecom.develop.di.DevSdk
object MessagesStorage {
    fun dialogs(): List<Chat> {
        return getDialogs().mapIndexed { id, dialog ->
            Chat(
                id.toLong(),
                dialog.name,
                dialog.messages.maxBy { message -> message.timestamp }
!!
            )
        }
    }
    fun dialogHistory(id: Long): List<Message> {
        val dialog = getDialogs()[id.toInt()]
        return dialog.messages
    }
    fun sendMessage(chatId: Long, text: String, time: Long, from: Stri
ng) {
        dialogs[chatId.toInt()].messages.add(Message(getId(), from, te
xt, time))
    }
    fun searchUser(pattern: String): List<User> {
        return if (pattern.length > 10) {
            emptyList()
        } else {
            listOf(
                User(100, "$pattern@email.com"),
                User(101, "lol@$pattern.edu.hse")
            )
        }
    }
    fun privateChatId(): Long {
        return 1000
    }
}
private fun getDialogs(): List<Dialog> {
    val settings = DevSdk.devComponent.devSettingsGateway()
    if (settings.emptyChatsList) return emptyList()
    return dialogs
}
private val dialogs = listOf(
    createDialog(
        "mock@user.com",
        "\xd0\x9f\xd1\x80\xd0\xb8\xd0\xb2\xd0\xb5\xd1\x82!" to 0,
        "\xd0\x9a\xd0\xb0\xd0\xba \xd0\xb4\xd0\xb5\xd0\xbb\xd0\xb0?" to 0,
        "\xd0\x9a\xd1\x83\xd0\xbf\xd0\xb8\xd0\xbb \xd0\xbd\xd0\xbe\xd0\xb2\xd1\x8b\xd0\xb9 \xd0\xba\xd0\xb0\xd0\xb4\xd0\xb8\xd0\xbb\xd0\xbb\xd0\xb0\xd0\xba." to 1,
        "\xd0\x9e\xd1\x82\xd0\xbb\xd0\xb8\xd1\x87\xd0\xbd\xd0\xbe" to 1,
        "\xd0\x90 \xd1\x83 \xd1\x82\xd0\xb5\xd0\xb1\xd1\x8f?" to 1,
        "\xd0\x9d\xd0\xbe\xd1\x80\xd0\xbc" to 0,
        "\xd0\x94\xd0\xbe\xd0\xbc\xd0\xb0\xd1\x88\xd0\xba\xd0\xb8 \xd0\xbc\xd0\xbd\xd0\xbe\xd0\xb3\xd0\xbe..." to 0,
        "\xd0\x96\xd0\xb8\xd0\xb7\xd0\xb0" to 1
    ),
    createDialog(
        "AlphaZero",
        "Lol" to 0,
        "Kek" to 1
    ),
    createDialog(
        "Lorem",
        "Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed 
do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim
 ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut al
iquip ex ea commodo consequat." to 0,
        "Sed ut perspiciatis unde omnis iste natus error sit voluptate
m accusantium doloremque laudantium, totam rem aperiam, eaque ipsa qua
e ab illo inventore veritatis et quasi architecto beatae vitae dicta s
unt explicabo." to 1,
        "Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed 
do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim
 ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut al
iquip ex ea commodo consequat." to 0,
        "Sed ut perspiciatis unde omnis iste natus error sit voluptate
m accusantium doloremque laudantium, totam rem aperiam, eaque ipsa qua
e ab illo inventore veritatis et quasi architecto beatae vitae dicta s
unt explicabo." to 1,
        "Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed 
do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim
 ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut al
iquip ex ea commodo consequat." to 0,
        "Sed ut perspiciatis unde omnis iste natus error sit voluptate
m accusantium doloremque laudantium, totam rem aperiam, eaque ipsa qua
e ab illo inventore veritatis et quasi architecto beatae vitae dicta s
unt explicabo." to 1
    )
)
private var globalTimestamp = 1616858199000L
private var globalId = -1L
const val MOCK_EMAIL = "demo@example.com"
const val MOCK_PASSWORD = "12345"
private fun getTimestamp(): Long {
    globalTimestamp += 10000
    return globalTimestamp
}
private fun getId(): Long {
    globalId += 1
    return globalId
}
private fun createMessageData(from: String, text: String): Message {
    return Message(
        getId(),
        from,
        text,
        getTimestamp()
    )
}
private class Dialog(
    val name: String,
    val messages: MutableList<Message>
)
private fun createDialog(user: String, vararg data: Pair<String, Int>)
: Dialog {
    val listOfMessageData = data.map { (text, fromId) ->
        val from = if (fromId == 0) MOCK_EMAIL else user
        createMessageData(from, text)
    }
    return Dialog(user, listOfMessageData.toMutableList())
}
\end{verbatim}

\subsection{MvpApiImpl.kt}
\begin{verbatim}
package com.closecom.app.api.data.repo.mvp
import com.closecom.app.api.domain.model.Chat
import com.closecom.app.api.domain.model.EmptyData
import com.closecom.app.api.domain.model.Message
import com.closecom.app.api.domain.model.Response
import com.closecom.app.api.domain.model.Token
import com.closecom.app.api.domain.model.User
import com.closecom.app.api.domain.repo.ClosecomAPI
import com.closecom.app.api.utils.assertNotUi
import javax.inject.Inject
class MvpApiImpl @Inject constructor() : ClosecomAPI {
    override fun createAccount(email: String, password: String): Respo
nse<Token> {
        assertNotUi()
        return Response.Success(Token("mocked_token_from_server"))
    }
    override fun authAccount(email: String, password: String): Respons
e<Token> {
        assertNotUi()
        return Response.Success(Token("mocked_token_from_server"))
    }
    override fun deleteAccount(token: String): Response<EmptyData> {
        assertNotUi()
        return Response.Success(EmptyData.instance)
    }
    override fun restoreAccountPassword(email: String): Response<Nothi
ng> {
        assertNotUi()
        return Response.Error(405, "some_interesting_error")
    }
    override fun chats(token: String): Response<List<Chat>> {
        assertNotUi()
        Thread.sleep(1000)
        return Response.Success(MessagesStorage.dialogs())
    }
    override fun chatHistory(token: String, chatId: Long): Response<Li
st<Message>> {
        assertNotUi()
        Thread.sleep(1000)
        return Response.Success(MessagesStorage.dialogHistory(chatId))
    }
    override fun startDialog(
        token: String,
        userId: Long,
        text: String,
        time: Long
    ): Response<Long> {
        Thread.sleep(1000)
        return Response.Success(MessagesStorage.privateChatId())
    }
    override fun userSearch(token: String, email: String): Response<Li
st<User>> {
        assertNotUi()
        Thread.sleep(1000)
        return Response.Success(MessagesStorage.searchUser(email))
    }
    override fun createChat(token: String, users: List<Long>): Respons
e<Long> {
        assertNotUi()
        Thread.sleep(1000)
        return Response.Error(401, "Not implemented")
    }
    override fun sendMessage(
        token: String,
        chatId: Long,
        text: String,
        time: Long
    ): Response<EmptyData> {
        assertNotUi()
        Thread.sleep(1000)
        MessagesStorage.sendMessage(chatId, text, time, MOCK_EMAIL)
        return Response.Success(EmptyData.instance)
    }
    override fun deleteMessage(token: String, messageId: Long): Respon
se<EmptyData> {
        assertNotUi()
        Thread.sleep(1000)
        return Response.Error(401, "Not implemented")
    }
    override fun deleteChat(token: String, chatId: Long): Response<Emp
tyData> {
        assertNotUi()
        Thread.sleep(1000)
        return Response.Error(401, "Not implemented")
    }
    override fun bluetoothUserAbout(bid: String): Response<User> {
        assertNotUi()
        Thread.sleep(1000)
        return Response.Error(401, "Not implemented")
    }
    override fun bluetoothSetBid(token: String, bid: String): Response
<EmptyData> {
        assertNotUi()
        Thread.sleep(1000)
        return Response.Error(401, "Not implemented")
    }
}
\end{verbatim}

\subsection{RequestImpl.kt}
\begin{verbatim}
package com.closecom.app.api.data.repo.requests
import android.util.Log
import com.closecom.app.api.domain.model.RequestResponse
import com.closecom.app.api.domain.model.RequestType
import com.closecom.app.api.domain.repo.requests.Request
import com.closecom.app.api.domain.repo.requests.RequestsBuilder
import org.json.JSONException
import org.json.JSONObject
import java.io.BufferedReader
import java.io.IOException
import java.io.InputStream
import java.io.InputStreamReader
import java.net.HttpURLConnection
import java.net.URL
private const val TAG = "RequestImpl"
private fun InputStream.toJSONObject(): JSONObject {
    val reader = BufferedReader(InputStreamReader(this, "UTF-8"))
    val result = StringBuilder()
    var str: String?
    str = reader.readLine()
    while (str != null) {
        result.append(str)
        str = reader.readLine()
    }
    reader.close()
    return try {
        JSONObject(result.toString())
    } catch (exception: JSONException) {
        Log.e(TAG, "Error json response: $result")
        JSONObject()
    }
}
class RequestImpl private constructor(
    private var url: String,
    private var params: List<Pair<String, String>> = emptyList(),
    private var headers: List<Pair<String, String>> = emptyList(),
    private var jsonBody: String,
    private var requestType: RequestType = RequestType.GET
) : Request {
    private lateinit var connection: HttpURLConnection
    override fun execute(): RequestResponse {
        val codeAndJson = try {
            connection = openConnection()
            connection.responseCode to connection.inputStream.toJSONOb
ject()
        } catch (exception: IOException) {
            connection.responseCode to connection.errorStream.toJSONOb
ject()
        } finally {
            connection.disconnect()
        }
        return RequestResponse(
            codeAndJson.first,
            codeAndJson.second
        )
    }
    private fun openConnection(): HttpURLConnection {
        val requestUrl = if (params.isNotEmpty()) {
            val buffer = StringBuffer("$url?")
            for (param in params) {
                buffer.append("${param.first}=${param.second}&")
            }
            buffer.removeSuffix("&")
            buffer.toString()
        } else {
            url
        }
        return (URL(requestUrl).openConnection() as HttpURLConnection)
.apply {
            requestMethod = requestType.str
            for (header in headers) {
                setRequestProperty(header.first, header.second)
            }
            if (jsonBody.isNotEmpty()) {
                doOutput = true
                outputStream.write(jsonBody.toByteArray())
            }
        }
    }
    class Builder(
        private var url: String? = null,
        private val params: MutableList<Pair<String, String>> = mutabl
eListOf(),
        private val headers: MutableList<Pair<String, String>> = mutab
leListOf(),
        private var jsonBody: String = "",
        private var requestType: RequestType = RequestType.GET
    ) : RequestsBuilder {
        override fun setUrl(url: String) = apply { this.url = url }
        override fun setJsonBody(jsonBody: Map<String, String>) =
            apply { this.jsonBody = JSONObject(jsonBody).toString() }
        override fun setParam(param: Pair<String, String>) =
            apply { this.params.add(param) }
        override fun setHeaderProperty(property: Pair<String, String>)
 =
            apply { this.headers.add(property) }
        override fun setRequestType(type: RequestType) = apply { this.
requestType = type }
        override fun build(): Request {
            return RequestImpl(
                url!!,
                params,
                headers,
                jsonBody,
                requestType
            )
        }
    }
}
\end{verbatim}

\subsection{RequestsBuilderFactoryImpl.kt}
\begin{verbatim}
package com.closecom.app.api.data.repo.requests
import com.closecom.app.api.domain.repo.requests.RequestsBuilder
import com.closecom.app.api.domain.repo.requests.RequestsBuilderFactor
y
import javax.inject.Inject
class RequestsBuilderFactoryImpl @Inject constructor() : RequestsBuild
erFactory {
    override fun createBuilder(): RequestsBuilder {
        return RequestImpl.Builder()
    }
}
\end{verbatim}

\subsection{ChatsParser.kt}
\begin{verbatim}
package com.closecom.app.api.domain.parsers
import com.closecom.app.api.domain.model.Chat
import com.closecom.app.api.domain.model.Message
import com.closecom.app.api.domain.model.User
import org.json.JSONObject
import javax.inject.Inject
class ChatsParser @Inject constructor(
    private val userParser: UserParser
) {
    fun parse(json: JSONObject): List<Chat> {
        return json.getJSONArray("chats").run {
            val res = mutableListOf<Chat>()
            for (i in 0 until length()) {
                res.add(parseChat(get(i) as JSONObject))
            }
            res
        }
    }
    private fun parseChat(json: JSONObject): Chat {
        val chatId = json.getLong("chat_id")
        val users = userParser.parseList(json.getJSONArray("users"))
        val name = json.getString("name")
        val lastMessage = json.getJSONObject("latest_message").run {
            Message(
                getLong("id"),
                users.find { it.id == getLong("user_id") }?.email ?: "
None",
                getString("text"),
                getLong("time")
            )
        }
        return Chat(
            chatId,
            name,
            lastMessage,
            users
        )
    }
}
\end{verbatim}

\subsection{UserSearchParser.kt}
\begin{verbatim}
package com.closecom.app.api.domain.parsers
import com.closecom.app.api.domain.model.User
import org.json.JSONObject
import javax.inject.Inject
class UserSearchParser @Inject constructor(
    private val userParser: UserParser
) {
    fun parse(jsonObject: JSONObject): List<User> {
        return userParser.parseList(jsonObject.getJSONArray("users"))
    }
}
\end{verbatim}

\subsection{ChatHistoryParser.kt}
\begin{verbatim}
package com.closecom.app.api.domain.parsers
import com.closecom.app.api.domain.model.Message
import com.closecom.app.api.domain.model.User
import org.json.JSONObject
import javax.inject.Inject
class ChatHistoryParser @Inject constructor(
    private val userParser: UserParser
) {
    fun parse(json: JSONObject): List<Message> {
        val users = userParser.parseList(json.getJSONArray("users"))
        return json.getJSONArray("messages").run {
            val res = mutableListOf<Message>()
            for (i in 0 until length()) {
                res.add(parseMessage(get(i) as JSONObject, users))
            }
            res
        }
    }
    private fun parseMessage(json: JSONObject, users: List<User>): Mes
sage {
        return Message(
            json.getLong("id"),
            users.find { it.id == json.getLong("user_id") }?.email ?: 
"",
            json.getString("text"),
            json.getLong("time")
        )
    }
}
\end{verbatim}

\subsection{UserParser.kt}
\begin{verbatim}
package com.closecom.app.api.domain.parsers
import com.closecom.app.api.domain.model.User
import org.json.JSONArray
import org.json.JSONObject
import javax.inject.Inject
class UserParser @Inject constructor() {
    fun parseList(json: JSONArray): List<User> {
        return json.run {
            val res = mutableListOf<User>()
            for (i in 0 until length()) {
                res.add(parse(get(i) as JSONObject))
            }
            res
        }
    }
    fun parse(json: JSONObject): User {
        return json.run {
            User(getLong("id"), getString("email"))
        }
    }
}
\end{verbatim}

\subsection{RequestResponse.kt}
\begin{verbatim}
package com.closecom.app.api.domain.model
import org.json.JSONObject
data class RequestResponse(
    val responseCode: Int,
    val jsonObject: JSONObject
) {
    val isSuccess: Boolean
        get() = responseCode < 400
}
\end{verbatim}

\subsection{Chat.kt}
\begin{verbatim}
package com.closecom.app.api.domain.model
class Chat(
    val id: Long,
    val name: String,
    val lastMessage: Message,
    val users: List<User> = listOf()
)
\end{verbatim}

\subsection{EmptyData.kt}
\begin{verbatim}
package com.closecom.app.api.domain.model
class EmptyData private constructor() {
    companion object {
        val instance = EmptyData()
    }
    override fun toString(): String {
        return "empty_data"
    }
}
\end{verbatim}

\subsection{Token.kt}
\begin{verbatim}
package com.closecom.app.api.domain.model
data class Token(private val token: String) {
    override fun toString(): String {
        return token
    }
}
\end{verbatim}

\subsection{User.kt}
\begin{verbatim}
package com.closecom.app.api.domain.model
data class User(
    val id: Long,
    val email: String
)
\end{verbatim}

\subsection{Response.kt}
\begin{verbatim}
package com.closecom.app.api.domain.model
sealed class Response<out R> {
    data class Success<out T>(val data: T) : Response<T>()
    data class Error(val responseCode: Int, val message: String) : Res
ponse<Nothing>()
}
\end{verbatim}

\subsection{Message.kt}
\begin{verbatim}
package com.closecom.app.api.domain.model
class Message(
    val id: Long,
    val from: String,
    val text: String?,
    val timestamp: Long
)
\end{verbatim}

\subsection{RequestType.kt}
\begin{verbatim}
package com.closecom.app.api.domain.model
enum class RequestType(val str: String) {
    GET("GET"),
    POST("POST")
}
\end{verbatim}

\subsection{ClosecomAPI.kt}
\begin{verbatim}
package com.closecom.app.api.domain.repo
import androidx.annotation.WorkerThread
import com.closecom.app.api.domain.model.Chat
import com.closecom.app.api.domain.model.EmptyData
import com.closecom.app.api.domain.model.Message
import com.closecom.app.api.domain.model.Response
import com.closecom.app.api.domain.model.Token
import com.closecom.app.api.domain.model.User
interface ClosecomAPI {
    @WorkerThread
    fun createAccount(email: String, password: String): Response<Token
>
    @WorkerThread
    fun authAccount(email: String, password: String): Response<Token>
    @WorkerThread
    fun deleteAccount(token: String): Response<EmptyData>
    @WorkerThread
    fun restoreAccountPassword(email: String): Response<EmptyData>
    @WorkerThread
    fun chats(token: String): Response<List<Chat>>
    @WorkerThread
    fun chatHistory(token: String, chatId: Long): Response<List<Messag
e>>
    @WorkerThread
    fun startDialog(
        token: String,
        userId: Long,
        text: String,
        time: Long
    ): Response<Long>
    @WorkerThread
    fun userSearch(token: String, email: String): Response<List<User>>
    @WorkerThread
    fun createChat(token: String, users: List<Long>): Response<Long>
    @WorkerThread
    fun sendMessage(token: String, chatId: Long, text: String, time: L
ong): Response<EmptyData>
    @WorkerThread
    fun deleteMessage(token: String, messageId: Long): Response<EmptyD
ata>
    @WorkerThread
    fun deleteChat(token: String, chatId: Long): Response<EmptyData>
    @WorkerThread
    fun bluetoothUserAbout(bid: String): Response<User>
    @WorkerThread
    fun bluetoothSetBid(token: String, bid: String): Response<EmptyDat
a>
}
\end{verbatim}

\subsection{RequestsBuilderFactory.kt}
\begin{verbatim}
package com.closecom.app.api.domain.repo.requests
interface RequestsBuilderFactory {
    fun createBuilder(): RequestsBuilder
}
\end{verbatim}

\subsection{RequestsBuilder.kt}
\begin{verbatim}
package com.closecom.app.api.domain.repo.requests
import com.closecom.app.api.domain.model.RequestType
interface RequestsBuilder {
    fun setUrl(url: String): RequestsBuilder
    fun setRequestType(type: RequestType): RequestsBuilder
    fun setHeaderProperty(property: Pair<String, String>): RequestsBui
lder
    fun setParam(param: Pair<String, String>): RequestsBuilder
    fun setJsonBody(jsonBody: Map<String, String>): RequestsBuilder
    fun build(): Request
}
\end{verbatim}

\subsection{Request.kt}
\begin{verbatim}
package com.closecom.app.api.domain.repo.requests
import com.closecom.app.api.domain.model.RequestResponse
interface Request {
    fun execute(): RequestResponse
}
\end{verbatim}

\section{Исходный код модуля develop}

\subsection{DevComponent.kt}
\begin{verbatim}
package com.closecom.develop.di
import com.closecom.develop.domain.repo.DevSettingsGateway
import dagger.Component
@Component(
    modules = [DevModule::class]
)
interface DevComponent {
    fun devSettingsGateway(): DevSettingsGateway
}
\end{verbatim}

\subsection{DevModule.kt}
\begin{verbatim}
package com.closecom.develop.di
import android.content.Context
import android.content.SharedPreferences
import com.closecom.develop.data.repo.DevSettingsRepo
import com.closecom.develop.domain.repo.DevSettingsGateway
import dagger.Module
import dagger.Provides
private const val KEY_DEV_PREFERENCES = "key_dev_preferences"
@Module
class DevModule(private val context: Context) {
    @Provides
    fun context(): Context = context.applicationContext
    @Provides
    fun sharedPrefs(context: Context): SharedPreferences =
        context.getSharedPreferences(KEY_DEV_PREFERENCES, Context.MODE
_PRIVATE)
    @Provides
    fun devSettingsGateway(devSettingsRepo: DevSettingsRepo): DevSetti
ngsGateway = devSettingsRepo
}
\end{verbatim}

\subsection{DevSdk.kt}
\begin{verbatim}
package com.closecom.develop.di
import android.content.Context
object DevSdk {
    private lateinit var context: Context
    val devComponent: DevComponent by lazy {
        DaggerDevComponent.builder()
            .devModule(DevModule(context))
            .build()
    }
    fun init(context: Context) {
        this.context = context
    }
}
\end{verbatim}

\subsection{DevSettingsRepo.kt}
\begin{verbatim}
package com.closecom.develop.data.repo
import android.content.SharedPreferences
import com.closecom.develop.domain.repo.DevSettingsGateway
import com.closecom.develop.domain.usecase.BooleanStorageUseCase
import javax.inject.Inject
private const val KEY_MOCK_API = "key_dev_mock_api"
private const val KEY_AUTO_LOGIN = "key_auto_login"
private const val KEY_EMPTY_CHAT_LIST = "key_empty_chat_list"
class DevSettingsRepo @Inject constructor(
    private val prefs: SharedPreferences,
    private val booleanStorage: BooleanStorageUseCase
) : DevSettingsGateway {
    override var mockApi: Boolean
        get() = booleanStorage.get(KEY_MOCK_API)
        set(value) = booleanStorage.put(KEY_MOCK_API, value)
    override var autoLogin: Boolean
        get() = booleanStorage.get(KEY_AUTO_LOGIN)
        set(value) = booleanStorage.put(KEY_AUTO_LOGIN, value)
    override var emptyChatsList: Boolean
        get() = booleanStorage.get(KEY_EMPTY_CHAT_LIST)
        set(value) = booleanStorage.put(KEY_EMPTY_CHAT_LIST, value)
    override fun reset() {
        prefs.edit()
            .clear()
            .apply()
    }
}
\end{verbatim}

\subsection{BooleanStorageUseCase.kt}
\begin{verbatim}
package com.closecom.develop.domain.usecase
import android.content.SharedPreferences
import javax.inject.Inject
class BooleanStorageUseCase @Inject constructor(
    private val prefs: SharedPreferences
) {
    fun get(key: String, defValue: Boolean = false): Boolean {
        return prefs.getBoolean(key, defValue)
    }
    fun put(key: String, value: Boolean) {
        prefs.edit()
            .putBoolean(key, value)
            .apply()
    }
}
\end{verbatim}

\subsection{DevSettingsGateway.kt}
\begin{verbatim}
package com.closecom.develop.domain.repo
interface DevSettingsGateway {
    var mockApi: Boolean
    var autoLogin: Boolean
    var emptyChatsList: Boolean
    fun reset()
}
\end{verbatim}


\bibliography{espd,library}

\end{document}
